ARM GAS  /tmp/ccQoOasm.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"util.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "Src/util.c"
  18              		.section	.text.BLDC_Init,"ax",%progbits
  19              		.align	1
  20              		.global	BLDC_Init
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  25              	BLDC_Init:
  26              	.LFB66:
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <stdlib.h> // for abs()
  23:Src/util.c    **** #include <string.h>
  24:Src/util.c    **** #include "stm32f1xx_hal.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "setup.h"
  27:Src/util.c    **** #include "config.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
  32:Src/util.c    **** #include "comms.h"
ARM GAS  /tmp/ccQoOasm.s 			page 2


  33:Src/util.c    **** 
  34:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  35:Src/util.c    **** #include "hd44780.h"
  36:Src/util.c    **** #endif
  37:Src/util.c    **** 
  38:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  39:Src/util.c    **** 
  40:Src/util.c    **** //------------------------------------------------------------------------
  41:Src/util.c    **** // Global variables set externally
  42:Src/util.c    **** //------------------------------------------------------------------------
  43:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  44:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart2;
  46:Src/util.c    **** extern UART_HandleTypeDef huart3;
  47:Src/util.c    **** 
  48:Src/util.c    **** extern int16_t batVoltage;
  49:Src/util.c    **** extern uint8_t backwardDrive;
  50:Src/util.c    **** extern uint8_t buzzerCount;             // global variable for the buzzer counts. can be 1, 2, 3, 4
  51:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  52:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  53:Src/util.c    **** 
  54:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  55:Src/util.c    **** 
  56:Src/util.c    **** extern uint8_t nunchuk_data[6];
  57:Src/util.c    **** extern volatile uint32_t timeoutCntGen; // global counter for general timeout counter
  58:Src/util.c    **** extern volatile uint8_t  timeoutFlgGen; // global flag for general timeout counter
  59:Src/util.c    **** extern volatile uint32_t main_loop_counter; 
  60:Src/util.c    **** extern uint32_t    inactivity_timeout_counter;
  61:Src/util.c    **** 
  62:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  63:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  64:Src/util.c    **** #endif
  65:Src/util.c    **** 
  66:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  67:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  68:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  69:Src/util.c    **** #endif
  70:Src/util.c    **** 
  71:Src/util.c    **** 
  72:Src/util.c    **** //------------------------------------------------------------------------
  73:Src/util.c    **** // Global variables set here in util.c
  74:Src/util.c    **** //------------------------------------------------------------------------
  75:Src/util.c    **** // Matlab defines - from auto-code generation
  76:Src/util.c    **** //---------------
  77:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  78:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  79:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  80:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  81:Src/util.c    **** 
  82:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  83:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  84:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  85:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  86:Src/util.c    **** 
  87:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  88:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  89:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
ARM GAS  /tmp/ccQoOasm.s 			page 3


  90:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
  91:Src/util.c    **** //---------------
  92:Src/util.c    **** 
  93:Src/util.c    **** uint8_t  inIdx      = 0;
  94:Src/util.c    **** uint8_t  inIdx_prev = 0;
  95:Src/util.c    **** #if defined(PRI_INPUT1) && defined(PRI_INPUT2) && defined(AUX_INPUT1) && defined(AUX_INPUT2)
  96:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1}, {0, 0, 0, AUX_INPUT1} };
  97:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2}, {0, 0, 0, AUX_INPUT2} };
  98:Src/util.c    **** #else
  99:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1} };
 100:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2} };
 101:Src/util.c    **** #endif
 102:Src/util.c    **** 
 103:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
 104:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
 105:Src/util.c    **** uint8_t  timeoutFlgADC    = 0;          // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 106:Src/util.c    **** uint8_t  timeoutFlgSerial = 0;          // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 107:Src/util.c    **** 
 108:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 109:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 110:Src/util.c    **** 
 111:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 112:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 113:Src/util.c    **** #endif
 114:Src/util.c    **** 
 115:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 116:Src/util.c    **** float    setDistance;
 117:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1337};       // Virtual address defined by the user: 0xFFFF va
 118:Src/util.c    **** static   uint16_t saveValue       = 0;
 119:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 120:Src/util.c    **** #elif !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 121:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
 122:Src/util.c    ****                                      1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018};
 123:Src/util.c    **** #else
 124:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000};       // Dummy virtual address to avoid warnings
 125:Src/util.c    **** #endif
 126:Src/util.c    **** 
 127:Src/util.c    **** 
 128:Src/util.c    **** //------------------------------------------------------------------------
 129:Src/util.c    **** // Local variables
 130:Src/util.c    **** //------------------------------------------------------------------------
 131:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 132:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 133:Src/util.c    **** 
 134:Src/util.c    **** 
 135:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 136:Src/util.c    ****   static uint8_t  cur_spd_valid  = 0;
 137:Src/util.c    ****   static uint8_t  inp_cal_valid  = 0;
 138:Src/util.c    **** #endif
 139:Src/util.c    **** 
 140:Src/util.c    **** #if defined(CONTROL_ADC)
 141:Src/util.c    **** static uint16_t timeoutCntADC = ADC_PROTECT_TIMEOUT;  // Timeout counter for ADC Protection
 142:Src/util.c    **** #endif
 143:Src/util.c    **** 
 144:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 145:Src/util.c    **** static uint8_t  rx_buffer_L[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 146:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
ARM GAS  /tmp/ccQoOasm.s 			page 4


 147:Src/util.c    **** #endif
 148:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 149:Src/util.c    **** static uint16_t timeoutCntSerial_L = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 150:Src/util.c    **** static uint8_t  timeoutFlgSerial_L = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 151:Src/util.c    **** #endif
 152:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 153:Src/util.c    **** SerialSideboard Sideboard_L;
 154:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 155:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 156:Src/util.c    **** #endif
 157:Src/util.c    **** 
 158:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 159:Src/util.c    **** static uint8_t  rx_buffer_R[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 160:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 161:Src/util.c    **** #endif
 162:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 163:Src/util.c    **** static uint16_t timeoutCntSerial_R = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 164:Src/util.c    **** static uint8_t  timeoutFlgSerial_R = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 165:Src/util.c    **** #endif
 166:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 167:Src/util.c    **** SerialSideboard Sideboard_R;
 168:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 169:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 170:Src/util.c    **** #endif
 171:Src/util.c    **** 
 172:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2)
 173:Src/util.c    **** static SerialCommand commandL;
 174:Src/util.c    **** static SerialCommand commandL_raw;
 175:Src/util.c    **** static uint32_t commandL_len = sizeof(commandL);
 176:Src/util.c    ****   #ifdef CONTROL_IBUS
 177:Src/util.c    ****   static uint16_t ibusL_captured_value[IBUS_NUM_CHANNELS];
 178:Src/util.c    ****   #endif
 179:Src/util.c    **** #endif
 180:Src/util.c    **** 
 181:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3)
 182:Src/util.c    **** static SerialCommand commandR;
 183:Src/util.c    **** static SerialCommand commandR_raw;
 184:Src/util.c    **** static uint32_t commandR_len = sizeof(commandR);
 185:Src/util.c    ****   #ifdef CONTROL_IBUS
 186:Src/util.c    ****   static uint16_t ibusR_captured_value[IBUS_NUM_CHANNELS];
 187:Src/util.c    ****   #endif
 188:Src/util.c    **** #endif
 189:Src/util.c    **** 
 190:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 191:Src/util.c    **** static uint8_t button1;                 // Blue
 192:Src/util.c    **** static uint8_t button2;                 // Green
 193:Src/util.c    **** #endif
 194:Src/util.c    **** 
 195:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 196:Src/util.c    **** static uint8_t brakePressed;
 197:Src/util.c    **** #endif
 198:Src/util.c    **** 
 199:Src/util.c    **** #if defined(CRUISE_CONTROL_SUPPORT) || (defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTR
 200:Src/util.c    **** static uint8_t cruiseCtrlAcv = 0;
 201:Src/util.c    **** static uint8_t standstillAcv = 0;
 202:Src/util.c    **** #endif
 203:Src/util.c    **** 
ARM GAS  /tmp/ccQoOasm.s 			page 5


 204:Src/util.c    **** /* =========================== Retargeting printf =========================== */
 205:Src/util.c    **** /* retarget the C library printf function to the USART */
 206:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 207:Src/util.c    ****   #ifdef __GNUC__
 208:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 209:Src/util.c    ****   #else
 210:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 211:Src/util.c    ****   #endif
 212:Src/util.c    ****   PUTCHAR_PROTOTYPE {
 213:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2)
 214:Src/util.c    ****       HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 1000);
 215:Src/util.c    ****     #elif defined(DEBUG_SERIAL_USART3)
 216:Src/util.c    ****       HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 1000);
 217:Src/util.c    ****     #endif
 218:Src/util.c    ****     return ch;
 219:Src/util.c    ****   }
 220:Src/util.c    ****   
 221:Src/util.c    ****   #ifdef __GNUC__
 222:Src/util.c    ****     int _write(int file, char *data, int len) {
 223:Src/util.c    ****       int i;
 224:Src/util.c    ****       for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 225:Src/util.c    ****       return len;
 226:Src/util.c    ****     }
 227:Src/util.c    ****   #endif
 228:Src/util.c    **** #endif
 229:Src/util.c    **** 
 230:Src/util.c    ****  
 231:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 232:Src/util.c    **** 
 233:Src/util.c    **** void BLDC_Init(void) {
  27              		.loc 1 233 22 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
 234:Src/util.c    ****   /* Set BLDC controller parameters */ 
 235:Src/util.c    ****   rtP_Left.b_angleMeasEna       = 0;            // Motor angle input: 0 = estimated angle, 1 = meas
  38              		.loc 1 235 3 view .LVU1
  39              		.loc 1 235 33 is_stmt 0 view .LVU2
  40 0002 214C     		ldr	r4, .L3
  41 0004 0023     		movs	r3, #0
  42 0006 84F8FB30 		strb	r3, [r4, #251]
 236:Src/util.c    ****   rtP_Left.z_selPhaCurMeasABC   = 0;            // Left motor measured current phases {Green, Blue}
  43              		.loc 1 236 3 is_stmt 1 view .LVU3
  44              		.loc 1 236 33 is_stmt 0 view .LVU4
  45 000a 84F8FA30 		strb	r3, [r4, #250]
 237:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
  46              		.loc 1 237 3 is_stmt 1 view .LVU5
  47              		.loc 1 237 33 is_stmt 0 view .LVU6
  48 000e 0222     		movs	r2, #2
  49 0010 84F8F920 		strb	r2, [r4, #249]
ARM GAS  /tmp/ccQoOasm.s 			page 6


 238:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA;
  50              		.loc 1 238 3 is_stmt 1 view .LVU7
  51              		.loc 1 238 33 is_stmt 0 view .LVU8
  52 0014 0126     		movs	r6, #1
  53 0016 84F8FD60 		strb	r6, [r4, #253]
 239:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
  54              		.loc 1 239 3 is_stmt 1 view .LVU9
  55              		.loc 1 239 33 is_stmt 0 view .LVU10
  56 001a 42F6E062 		movw	r2, #12000
  57 001e A4F8CE20 		strh	r2, [r4, #206]	@ movhi
 240:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
  58              		.loc 1 240 3 is_stmt 1 view .LVU11
  59              		.loc 1 240 33 is_stmt 0 view .LVU12
  60 0022 4FF47071 		mov	r1, #960
  61 0026 A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 241:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
  62              		.loc 1 241 3 is_stmt 1 view .LVU13
  63              		.loc 1 241 33 is_stmt 0 view .LVU14
  64 002a 84F8FE30 		strb	r3, [r4, #254]
 242:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
  65              		.loc 1 242 3 is_stmt 1 view .LVU15
  66              		.loc 1 242 33 is_stmt 0 view .LVU16
  67 002e 4FF47A63 		mov	r3, #4000
  68 0032 A4F8D030 		strh	r3, [r4, #208]	@ movhi
 243:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
  69              		.loc 1 243 3 is_stmt 1 view .LVU17
  70              		.loc 1 243 33 is_stmt 0 view .LVU18
  71 0036 4FF4C873 		mov	r3, #400
  72 003a A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 244:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
  73              		.loc 1 244 3 is_stmt 1 view .LVU19
  74              		.loc 1 244 33 is_stmt 0 view .LVU20
  75 003e 4FF47A53 		mov	r3, #16000
  76 0042 A4F8E030 		strh	r3, [r4, #224]	@ movhi
 245:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
  77              		.loc 1 245 3 is_stmt 1 view .LVU21
  78              		.loc 1 245 33 is_stmt 0 view .LVU22
  79 0046 A4F8E220 		strh	r2, [r4, #226]	@ movhi
 246:Src/util.c    **** 
 247:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
  80              		.loc 1 247 3 is_stmt 1 view .LVU23
  81              		.loc 1 247 33 is_stmt 0 view .LVU24
  82 004a 104D     		ldr	r5, .L3+4
  83 004c 4FF48072 		mov	r2, #256
  84 0050 2146     		mov	r1, r4
  85 0052 2846     		mov	r0, r5
  86 0054 FFF7FEFF 		bl	memcpy
  87              	.LVL0:
 248:Src/util.c    ****   rtP_Right.z_selPhaCurMeasABC  = 1;            // Right motor measured current phases {Blue, Yello
  88              		.loc 1 248 3 is_stmt 1 view .LVU25
  89              		.loc 1 248 33 is_stmt 0 view .LVU26
  90 0058 85F8FA60 		strb	r6, [r5, #250]
 249:Src/util.c    **** 
 250:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 251:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
  91              		.loc 1 251 3 is_stmt 1 view .LVU27
  92              		.loc 1 251 33 is_stmt 0 view .LVU28
ARM GAS  /tmp/ccQoOasm.s 			page 7


  93 005c 0C48     		ldr	r0, .L3+8
  94 005e 0460     		str	r4, [r0]
 252:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
  95              		.loc 1 252 3 is_stmt 1 view .LVU29
  96              		.loc 1 252 33 is_stmt 0 view .LVU30
  97 0060 0C4B     		ldr	r3, .L3+12
  98 0062 C360     		str	r3, [r0, #12]
 253:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
  99              		.loc 1 253 3 is_stmt 1 view .LVU31
 100              		.loc 1 253 33 is_stmt 0 view .LVU32
 101 0064 0C4B     		ldr	r3, .L3+16
 102 0066 4360     		str	r3, [r0, #4]
 254:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
 103              		.loc 1 254 3 is_stmt 1 view .LVU33
 104              		.loc 1 254 33 is_stmt 0 view .LVU34
 105 0068 0C4B     		ldr	r3, .L3+20
 106 006a 8360     		str	r3, [r0, #8]
 255:Src/util.c    **** 
 256:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 257:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
 107              		.loc 1 257 3 is_stmt 1 view .LVU35
 108              		.loc 1 257 33 is_stmt 0 view .LVU36
 109 006c 0C4C     		ldr	r4, .L3+24
 110 006e 2560     		str	r5, [r4]
 258:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
 111              		.loc 1 258 3 is_stmt 1 view .LVU37
 112              		.loc 1 258 33 is_stmt 0 view .LVU38
 113 0070 0C4B     		ldr	r3, .L3+28
 114 0072 E360     		str	r3, [r4, #12]
 259:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
 115              		.loc 1 259 3 is_stmt 1 view .LVU39
 116              		.loc 1 259 33 is_stmt 0 view .LVU40
 117 0074 0C4B     		ldr	r3, .L3+32
 118 0076 6360     		str	r3, [r4, #4]
 260:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
 119              		.loc 1 260 3 is_stmt 1 view .LVU41
 120              		.loc 1 260 33 is_stmt 0 view .LVU42
 121 0078 0C4B     		ldr	r3, .L3+36
 122 007a A360     		str	r3, [r4, #8]
 261:Src/util.c    **** 
 262:Src/util.c    ****   /* Initialize BLDC controllers */
 263:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
 123              		.loc 1 263 3 is_stmt 1 view .LVU43
 124 007c FFF7FEFF 		bl	BLDC_controller_initialize
 125              	.LVL1:
 264:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
 126              		.loc 1 264 3 view .LVU44
 127 0080 2046     		mov	r0, r4
 128 0082 FFF7FEFF 		bl	BLDC_controller_initialize
 129              	.LVL2:
 265:Src/util.c    **** }
 130              		.loc 1 265 1 is_stmt 0 view .LVU45
 131 0086 70BD     		pop	{r4, r5, r6, pc}
 132              	.L4:
 133              		.align	2
 134              	.L3:
 135 0088 00000000 		.word	rtP_Left
ARM GAS  /tmp/ccQoOasm.s 			page 8


 136 008c 00000000 		.word	rtP_Right
 137 0090 00000000 		.word	rtM_Left_
 138 0094 00000000 		.word	rtDW_Left
 139 0098 00000000 		.word	rtU_Left
 140 009c 00000000 		.word	rtY_Left
 141 00a0 00000000 		.word	rtM_Right_
 142 00a4 00000000 		.word	rtDW_Right
 143 00a8 00000000 		.word	rtU_Right
 144 00ac 00000000 		.word	rtY_Right
 145              		.cfi_endproc
 146              	.LFE66:
 148              		.section	.text.Input_Lim_Init,"ax",%progbits
 149              		.align	1
 150              		.global	Input_Lim_Init
 151              		.syntax unified
 152              		.thumb
 153              		.thumb_func
 155              	Input_Lim_Init:
 156              	.LFB67:
 266:Src/util.c    **** 
 267:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !
 157              		.loc 1 267 27 is_stmt 1 view -0
 158              		.cfi_startproc
 159              		@ args = 0, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              		@ link register save eliminated.
 268:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 162              		.loc 1 268 3 view .LVU47
 163              		.loc 1 268 15 is_stmt 0 view .LVU48
 164 0000 0C4B     		ldr	r3, .L9
 165 0002 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 166              		.loc 1 268 6 view .LVU49
 167 0006 1BB9     		cbnz	r3, .L6
 168              		.loc 1 268 43 discriminator 1 view .LVU50
 169 0008 0B4B     		ldr	r3, .L9+4
 170 000a 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 171              		.loc 1 268 31 discriminator 1 view .LVU51
 172 000e 43B1     		cbz	r3, .L7
 173              	.L6:
 269:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 174              		.loc 1 269 5 is_stmt 1 view .LVU52
 175              		.loc 1 269 15 is_stmt 0 view .LVU53
 176 0010 0A4B     		ldr	r3, .L9+8
 177 0012 4FF47A72 		mov	r2, #1000
 178 0016 1A80     		strh	r2, [r3]	@ movhi
 270:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 179              		.loc 1 270 5 is_stmt 1 view .LVU54
 180              		.loc 1 270 15 is_stmt 0 view .LVU55
 181 0018 094B     		ldr	r3, .L9+12
 182 001a 4FF61842 		movw	r2, #64536
 183 001e 1A80     		strh	r2, [r3]	@ movhi
 184 0020 7047     		bx	lr
 185              	.L7:
 271:Src/util.c    ****   } else {
 272:Src/util.c    ****     INPUT_MAX =  1000;
 186              		.loc 1 272 5 is_stmt 1 view .LVU56
 187              		.loc 1 272 15 is_stmt 0 view .LVU57
ARM GAS  /tmp/ccQoOasm.s 			page 9


 188 0022 064B     		ldr	r3, .L9+8
 189 0024 4FF47A72 		mov	r2, #1000
 190 0028 1A80     		strh	r2, [r3]	@ movhi
 273:Src/util.c    ****     INPUT_MIN = -1000;
 191              		.loc 1 273 5 is_stmt 1 view .LVU58
 192              		.loc 1 273 15 is_stmt 0 view .LVU59
 193 002a 054B     		ldr	r3, .L9+12
 194 002c 4FF61842 		movw	r2, #64536
 195 0030 1A80     		strh	r2, [r3]	@ movhi
 274:Src/util.c    ****   }
 275:Src/util.c    **** }
 196              		.loc 1 275 1 view .LVU60
 197 0032 7047     		bx	lr
 198              	.L10:
 199              		.align	2
 200              	.L9:
 201 0034 00000000 		.word	rtP_Left
 202 0038 00000000 		.word	rtP_Right
 203 003c 00000000 		.word	INPUT_MAX
 204 0040 00000000 		.word	INPUT_MIN
 205              		.cfi_endproc
 206              	.LFE67:
 208              		.section	.text.UART_DisableRxErrors,"ax",%progbits
 209              		.align	1
 210              		.global	UART_DisableRxErrors
 211              		.syntax unified
 212              		.thumb
 213              		.thumb_func
 215              	UART_DisableRxErrors:
 216              	.LVL3:
 217              	.LFB69:
 276:Src/util.c    **** 
 277:Src/util.c    **** void Input_Init(void) {
 278:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 279:Src/util.c    ****     PPM_Init();
 280:Src/util.c    ****   #endif
 281:Src/util.c    **** 
 282:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 283:Src/util.c    ****     PWM_Init();
 284:Src/util.c    ****   #endif
 285:Src/util.c    **** 
 286:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
 287:Src/util.c    ****     UART2_Init();
 288:Src/util.c    ****   #endif
 289:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 290:Src/util.c    ****     UART3_Init();
 291:Src/util.c    ****   #endif
 292:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 293:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 294:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 295:Src/util.c    ****   #endif
 296:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 297:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 298:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 299:Src/util.c    ****   #endif
 300:Src/util.c    **** 
 301:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
ARM GAS  /tmp/ccQoOasm.s 			page 10


 302:Src/util.c    ****     uint16_t writeCheck, readVal;
 303:Src/util.c    ****     HAL_FLASH_Unlock();
 304:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 305:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 306:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 307:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 308:Src/util.c    ****         printf("Using the configuration from EEprom\r\n");
 309:Src/util.c    ****       #endif
 310:Src/util.c    **** 
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 312:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 313:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 321:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 322:Src/util.c    ****       
 323:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 324:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 325:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 326:Src/util.c    ****       }
 327:Src/util.c    ****     } else {
 328:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 329:Src/util.c    ****         printf("Using the configuration from config.h\r\n");
 330:Src/util.c    ****       #endif
 331:Src/util.c    **** 
 332:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 334:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 335:Src/util.c    ****         } else {
 336:Src/util.c    ****           input1[i].typ = input1[i].typDef;
 337:Src/util.c    ****         }
 338:Src/util.c    ****         if (input2[i].typDef == 3) {
 339:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 340:Src/util.c    ****         } else {
 341:Src/util.c    ****           input2[i].typ = input2[i].typDef;
 342:Src/util.c    ****         }
 343:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 344:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 345:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 346:Src/util.c    ****       }
 347:Src/util.c    ****     }
 348:Src/util.c    ****     HAL_FLASH_Lock();
 349:Src/util.c    ****   #endif
 350:Src/util.c    **** 
 351:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 352:Src/util.c    ****     enable = 1;
 353:Src/util.c    **** 
 354:Src/util.c    ****     HAL_FLASH_Unlock();
 355:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 356:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 357:Src/util.c    ****     HAL_FLASH_Lock();
 358:Src/util.c    **** 
ARM GAS  /tmp/ccQoOasm.s 			page 11


 359:Src/util.c    ****     setDistance = saveValue / 1000.0;
 360:Src/util.c    ****     if (setDistance < 0.2) {
 361:Src/util.c    ****       setDistance = 1.0;
 362:Src/util.c    ****     }
 363:Src/util.c    ****   #endif
 364:Src/util.c    **** 
 365:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 366:Src/util.c    ****     I2C_Init();
 367:Src/util.c    ****     HAL_Delay(50);
 368:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 369:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 370:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 371:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 372:Src/util.c    ****     lcd.type                    = TYPE0;
 373:Src/util.c    **** 
 374:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
 375:Src/util.c    ****         // error occured
 376:Src/util.c    ****         //TODO while(1);
 377:Src/util.c    ****     }
 378:Src/util.c    **** 
 379:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 380:Src/util.c    ****     HAL_Delay(5);
 381:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 382:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 383:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 384:Src/util.c    ****     #else
 385:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 386:Src/util.c    ****     #endif
 387:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 388:Src/util.c    ****   #endif
 389:Src/util.c    **** 
 390:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 391:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 392:Src/util.c    ****     HAL_Delay(5);
 393:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 394:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 395:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 396:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 397:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 398:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 399:Src/util.c    ****   #endif
 400:Src/util.c    **** }
 401:Src/util.c    **** 
 402:Src/util.c    **** /**
 403:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 404:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 405:Src/util.c    ****   * @param  huart: UART handle.
 406:Src/util.c    ****   * @retval None
 407:Src/util.c    ****   */
 408:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 409:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 410:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 411:Src/util.c    **** {  
 218              		.loc 1 411 1 is_stmt 1 view -0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccQoOasm.s 			page 12


 222              		@ link register save eliminated.
 412:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);    /* Disable PE (Parity Error) interrupts */  
 223              		.loc 1 412 3 view .LVU62
 224 0000 0268     		ldr	r2, [r0]
 225 0002 D368     		ldr	r3, [r2, #12]
 226 0004 23F48073 		bic	r3, r3, #256
 227 0008 D360     		str	r3, [r2, #12]
 413:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);     /* Disable EIE (Frame error, noise error, ove
 228              		.loc 1 413 3 view .LVU63
 229 000a 0268     		ldr	r2, [r0]
 230 000c 5369     		ldr	r3, [r2, #20]
 231 000e 23F00103 		bic	r3, r3, #1
 232 0012 5361     		str	r3, [r2, #20]
 414:Src/util.c    **** }
 233              		.loc 1 414 1 is_stmt 0 view .LVU64
 234 0014 7047     		bx	lr
 235              		.cfi_endproc
 236              	.LFE69:
 238              		.section	.text.poweronMelody,"ax",%progbits
 239              		.align	1
 240              		.global	poweronMelody
 241              		.syntax unified
 242              		.thumb
 243              		.thumb_func
 245              	poweronMelody:
 246              	.LFB70:
 415:Src/util.c    **** #endif
 416:Src/util.c    **** 
 417:Src/util.c    **** 
 418:Src/util.c    **** /* =========================== General Functions =========================== */
 419:Src/util.c    **** 
 420:Src/util.c    **** void poweronMelody(void) {
 247              		.loc 1 420 26 is_stmt 1 view -0
 248              		.cfi_startproc
 249              		@ args = 0, pretend = 0, frame = 0
 250              		@ frame_needed = 0, uses_anonymous_args = 0
 251 0000 10B5     		push	{r4, lr}
 252              	.LCFI1:
 253              		.cfi_def_cfa_offset 8
 254              		.cfi_offset 4, -8
 255              		.cfi_offset 14, -4
 421:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 256              		.loc 1 421 5 view .LVU66
 257              		.loc 1 421 17 is_stmt 0 view .LVU67
 258 0002 084B     		ldr	r3, .L16
 259 0004 0022     		movs	r2, #0
 260 0006 1A70     		strb	r2, [r3]
 422:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 261              		.loc 1 422 5 is_stmt 1 view .LVU68
 262              	.LBB2:
 263              		.loc 1 422 10 view .LVU69
 264              	.LVL4:
 265              		.loc 1 422 14 is_stmt 0 view .LVU70
 266 0008 0824     		movs	r4, #8
 267              		.loc 1 422 5 view .LVU71
 268 000a 05E0     		b	.L13
 269              	.LVL5:
ARM GAS  /tmp/ccQoOasm.s 			page 13


 270              	.L14:
 423:Src/util.c    ****       buzzerFreq = (uint8_t)i;
 271              		.loc 1 423 7 is_stmt 1 view .LVU72
 272              		.loc 1 423 18 is_stmt 0 view .LVU73
 273 000c 064B     		ldr	r3, .L16+4
 274 000e 1C70     		strb	r4, [r3]
 424:Src/util.c    ****       HAL_Delay(100);
 275              		.loc 1 424 7 is_stmt 1 view .LVU74
 276 0010 6420     		movs	r0, #100
 277 0012 FFF7FEFF 		bl	HAL_Delay
 278              	.LVL6:
 422:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 279              		.loc 1 422 30 discriminator 3 view .LVU75
 280 0016 013C     		subs	r4, r4, #1
 281              	.LVL7:
 282              	.L13:
 422:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 283              		.loc 1 422 23 discriminator 1 view .LVU76
 284 0018 002C     		cmp	r4, #0
 285 001a F7DA     		bge	.L14
 286              	.LBE2:
 425:Src/util.c    ****     }
 426:Src/util.c    ****     buzzerFreq = 0;
 287              		.loc 1 426 5 view .LVU77
 288              		.loc 1 426 16 is_stmt 0 view .LVU78
 289 001c 024B     		ldr	r3, .L16+4
 290 001e 0022     		movs	r2, #0
 291 0020 1A70     		strb	r2, [r3]
 427:Src/util.c    **** }
 292              		.loc 1 427 1 view .LVU79
 293 0022 10BD     		pop	{r4, pc}
 294              	.LVL8:
 295              	.L17:
 296              		.loc 1 427 1 view .LVU80
 297              		.align	2
 298              	.L16:
 299 0024 00000000 		.word	buzzerCount
 300 0028 00000000 		.word	buzzerFreq
 301              		.cfi_endproc
 302              	.LFE70:
 304              		.section	.text.beepCount,"ax",%progbits
 305              		.align	1
 306              		.global	beepCount
 307              		.syntax unified
 308              		.thumb
 309              		.thumb_func
 311              	beepCount:
 312              	.LVL9:
 313              	.LFB71:
 428:Src/util.c    **** 
 429:Src/util.c    **** void beepCount(uint8_t cnt, uint8_t freq, uint8_t pattern) {
 314              		.loc 1 429 60 is_stmt 1 view -0
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 0
 317              		@ frame_needed = 0, uses_anonymous_args = 0
 318              		@ link register save eliminated.
 430:Src/util.c    ****     buzzerCount   = cnt;
ARM GAS  /tmp/ccQoOasm.s 			page 14


 319              		.loc 1 430 5 view .LVU82
 320              		.loc 1 430 19 is_stmt 0 view .LVU83
 321 0000 034B     		ldr	r3, .L19
 322 0002 1870     		strb	r0, [r3]
 431:Src/util.c    ****     buzzerFreq    = freq;
 323              		.loc 1 431 5 is_stmt 1 view .LVU84
 324              		.loc 1 431 19 is_stmt 0 view .LVU85
 325 0004 034B     		ldr	r3, .L19+4
 326 0006 1970     		strb	r1, [r3]
 432:Src/util.c    ****     buzzerPattern = pattern;
 327              		.loc 1 432 5 is_stmt 1 view .LVU86
 328              		.loc 1 432 19 is_stmt 0 view .LVU87
 329 0008 034B     		ldr	r3, .L19+8
 330 000a 1A70     		strb	r2, [r3]
 433:Src/util.c    **** }
 331              		.loc 1 433 1 view .LVU88
 332 000c 7047     		bx	lr
 333              	.L20:
 334 000e 00BF     		.align	2
 335              	.L19:
 336 0010 00000000 		.word	buzzerCount
 337 0014 00000000 		.word	buzzerFreq
 338 0018 00000000 		.word	buzzerPattern
 339              		.cfi_endproc
 340              	.LFE71:
 342              		.section	.text.beepLong,"ax",%progbits
 343              		.align	1
 344              		.global	beepLong
 345              		.syntax unified
 346              		.thumb
 347              		.thumb_func
 349              	beepLong:
 350              	.LVL10:
 351              	.LFB72:
 434:Src/util.c    **** 
 435:Src/util.c    **** void beepLong(uint8_t freq) {
 352              		.loc 1 435 29 is_stmt 1 view -0
 353              		.cfi_startproc
 354              		@ args = 0, pretend = 0, frame = 0
 355              		@ frame_needed = 0, uses_anonymous_args = 0
 356              		.loc 1 435 29 is_stmt 0 view .LVU90
 357 0000 38B5     		push	{r3, r4, r5, lr}
 358              	.LCFI2:
 359              		.cfi_def_cfa_offset 16
 360              		.cfi_offset 3, -16
 361              		.cfi_offset 4, -12
 362              		.cfi_offset 5, -8
 363              		.cfi_offset 14, -4
 436:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 364              		.loc 1 436 5 is_stmt 1 view .LVU91
 365              		.loc 1 436 17 is_stmt 0 view .LVU92
 366 0002 0025     		movs	r5, #0
 367 0004 044B     		ldr	r3, .L23
 368 0006 1D70     		strb	r5, [r3]
 437:Src/util.c    ****     buzzerFreq = freq;
 369              		.loc 1 437 5 is_stmt 1 view .LVU93
 370              		.loc 1 437 16 is_stmt 0 view .LVU94
ARM GAS  /tmp/ccQoOasm.s 			page 15


 371 0008 044C     		ldr	r4, .L23+4
 372 000a 2070     		strb	r0, [r4]
 438:Src/util.c    ****     HAL_Delay(500);
 373              		.loc 1 438 5 is_stmt 1 view .LVU95
 374 000c 4FF4FA70 		mov	r0, #500
 375              	.LVL11:
 376              		.loc 1 438 5 is_stmt 0 view .LVU96
 377 0010 FFF7FEFF 		bl	HAL_Delay
 378              	.LVL12:
 439:Src/util.c    ****     buzzerFreq = 0;
 379              		.loc 1 439 5 is_stmt 1 view .LVU97
 380              		.loc 1 439 16 is_stmt 0 view .LVU98
 381 0014 2570     		strb	r5, [r4]
 440:Src/util.c    **** }
 382              		.loc 1 440 1 view .LVU99
 383 0016 38BD     		pop	{r3, r4, r5, pc}
 384              	.L24:
 385              		.align	2
 386              	.L23:
 387 0018 00000000 		.word	buzzerCount
 388 001c 00000000 		.word	buzzerFreq
 389              		.cfi_endproc
 390              	.LFE72:
 392              		.section	.text.beepShort,"ax",%progbits
 393              		.align	1
 394              		.global	beepShort
 395              		.syntax unified
 396              		.thumb
 397              		.thumb_func
 399              	beepShort:
 400              	.LVL13:
 401              	.LFB73:
 441:Src/util.c    **** 
 442:Src/util.c    **** void beepShort(uint8_t freq) {
 402              		.loc 1 442 30 is_stmt 1 view -0
 403              		.cfi_startproc
 404              		@ args = 0, pretend = 0, frame = 0
 405              		@ frame_needed = 0, uses_anonymous_args = 0
 406              		.loc 1 442 30 is_stmt 0 view .LVU101
 407 0000 38B5     		push	{r3, r4, r5, lr}
 408              	.LCFI3:
 409              		.cfi_def_cfa_offset 16
 410              		.cfi_offset 3, -16
 411              		.cfi_offset 4, -12
 412              		.cfi_offset 5, -8
 413              		.cfi_offset 14, -4
 443:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 414              		.loc 1 443 5 is_stmt 1 view .LVU102
 415              		.loc 1 443 17 is_stmt 0 view .LVU103
 416 0002 0025     		movs	r5, #0
 417 0004 044B     		ldr	r3, .L27
 418 0006 1D70     		strb	r5, [r3]
 444:Src/util.c    ****     buzzerFreq = freq;
 419              		.loc 1 444 5 is_stmt 1 view .LVU104
 420              		.loc 1 444 16 is_stmt 0 view .LVU105
 421 0008 044C     		ldr	r4, .L27+4
 422 000a 2070     		strb	r0, [r4]
ARM GAS  /tmp/ccQoOasm.s 			page 16


 445:Src/util.c    ****     HAL_Delay(100);
 423              		.loc 1 445 5 is_stmt 1 view .LVU106
 424 000c 6420     		movs	r0, #100
 425              	.LVL14:
 426              		.loc 1 445 5 is_stmt 0 view .LVU107
 427 000e FFF7FEFF 		bl	HAL_Delay
 428              	.LVL15:
 446:Src/util.c    ****     buzzerFreq = 0;
 429              		.loc 1 446 5 is_stmt 1 view .LVU108
 430              		.loc 1 446 16 is_stmt 0 view .LVU109
 431 0012 2570     		strb	r5, [r4]
 447:Src/util.c    **** }
 432              		.loc 1 447 1 view .LVU110
 433 0014 38BD     		pop	{r3, r4, r5, pc}
 434              	.L28:
 435 0016 00BF     		.align	2
 436              	.L27:
 437 0018 00000000 		.word	buzzerCount
 438 001c 00000000 		.word	buzzerFreq
 439              		.cfi_endproc
 440              	.LFE73:
 442              		.section	.text.beepShortMany,"ax",%progbits
 443              		.align	1
 444              		.global	beepShortMany
 445              		.syntax unified
 446              		.thumb
 447              		.thumb_func
 449              	beepShortMany:
 450              	.LVL16:
 451              	.LFB74:
 448:Src/util.c    **** 
 449:Src/util.c    **** void beepShortMany(uint8_t cnt, int8_t dir) {
 452              		.loc 1 449 45 is_stmt 1 view -0
 453              		.cfi_startproc
 454              		@ args = 0, pretend = 0, frame = 0
 455              		@ frame_needed = 0, uses_anonymous_args = 0
 456              		.loc 1 449 45 is_stmt 0 view .LVU112
 457 0000 38B5     		push	{r3, r4, r5, lr}
 458              	.LCFI4:
 459              		.cfi_def_cfa_offset 16
 460              		.cfi_offset 3, -16
 461              		.cfi_offset 4, -12
 462              		.cfi_offset 5, -8
 463              		.cfi_offset 14, -4
 464 0002 0446     		mov	r4, r0
 450:Src/util.c    ****     if (dir >= 0) {   // increasing tone
 465              		.loc 1 450 5 is_stmt 1 view .LVU113
 466              		.loc 1 450 8 is_stmt 0 view .LVU114
 467 0004 0029     		cmp	r1, #0
 468 0006 15DB     		blt	.L35
 451:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 469              		.loc 1 451 7 is_stmt 1 view .LVU115
 470              	.LBB3:
 471              		.loc 1 451 11 view .LVU116
 472              		.loc 1 451 19 is_stmt 0 view .LVU117
 473 0008 4400     		lsls	r4, r0, #1
 474 000a E4B2     		uxtb	r4, r4
ARM GAS  /tmp/ccQoOasm.s 			page 17


 475              	.LVL17:
 476              		.loc 1 451 7 view .LVU118
 477 000c 05E0     		b	.L31
 478              	.LVL18:
 479              	.L32:
 452:Src/util.c    ****         beepShort(i + 3);
 480              		.loc 1 452 9 is_stmt 1 view .LVU119
 481 000e E01C     		adds	r0, r4, #3
 482 0010 C0B2     		uxtb	r0, r0
 483 0012 FFF7FEFF 		bl	beepShort
 484              	.LVL19:
 451:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 485              		.loc 1 451 39 discriminator 3 view .LVU120
 486 0016 023C     		subs	r4, r4, #2
 487              	.LVL20:
 451:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 488              		.loc 1 451 39 is_stmt 0 discriminator 3 view .LVU121
 489 0018 E4B2     		uxtb	r4, r4
 490              	.LVL21:
 491              	.L31:
 451:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 492              		.loc 1 451 32 is_stmt 1 discriminator 1 view .LVU122
 493 001a 012C     		cmp	r4, #1
 494 001c F7D8     		bhi	.L32
 495              	.LVL22:
 496              	.L29:
 451:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 497              		.loc 1 451 32 is_stmt 0 discriminator 1 view .LVU123
 498              	.LBE3:
 453:Src/util.c    ****       }
 454:Src/util.c    ****     } else {          // decreasing tone
 455:Src/util.c    ****       for(uint8_t i = 2; i <= 2*cnt; i=i+2) {
 456:Src/util.c    ****         beepShort(i + 3);
 457:Src/util.c    ****       }
 458:Src/util.c    ****     }
 459:Src/util.c    **** }
 499              		.loc 1 459 1 view .LVU124
 500 001e 38BD     		pop	{r3, r4, r5, pc}
 501              	.LVL23:
 502              	.L34:
 503              	.LBB4:
 456:Src/util.c    ****       }
 504              		.loc 1 456 9 is_stmt 1 view .LVU125
 505 0020 E81C     		adds	r0, r5, #3
 506 0022 C0B2     		uxtb	r0, r0
 507 0024 FFF7FEFF 		bl	beepShort
 508              	.LVL24:
 455:Src/util.c    ****         beepShort(i + 3);
 509              		.loc 1 455 39 discriminator 3 view .LVU126
 510 0028 0235     		adds	r5, r5, #2
 511              	.LVL25:
 455:Src/util.c    ****         beepShort(i + 3);
 512              		.loc 1 455 39 is_stmt 0 discriminator 3 view .LVU127
 513 002a EDB2     		uxtb	r5, r5
 514              	.LVL26:
 515              	.L30:
 455:Src/util.c    ****         beepShort(i + 3);
ARM GAS  /tmp/ccQoOasm.s 			page 18


 516              		.loc 1 455 28 is_stmt 1 discriminator 1 view .LVU128
 517 002c B5EB440F 		cmp	r5, r4, lsl #1
 518 0030 F6DD     		ble	.L34
 519 0032 F4E7     		b	.L29
 520              	.LVL27:
 521              	.L35:
 455:Src/util.c    ****         beepShort(i + 3);
 522              		.loc 1 455 19 is_stmt 0 view .LVU129
 523 0034 0225     		movs	r5, #2
 524 0036 F9E7     		b	.L30
 525              	.LBE4:
 526              		.cfi_endproc
 527              	.LFE74:
 529              		.section	.text.calcAvgSpeed,"ax",%progbits
 530              		.align	1
 531              		.global	calcAvgSpeed
 532              		.syntax unified
 533              		.thumb
 534              		.thumb_func
 536              	calcAvgSpeed:
 537              	.LFB75:
 460:Src/util.c    **** 
 461:Src/util.c    **** void calcAvgSpeed(void) {
 538              		.loc 1 461 25 is_stmt 1 view -0
 539              		.cfi_startproc
 540              		@ args = 0, pretend = 0, frame = 0
 541              		@ frame_needed = 0, uses_anonymous_args = 0
 542              		@ link register save eliminated.
 462:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 463:Src/util.c    ****     speedAvg = 0;
 543              		.loc 1 463 5 view .LVU131
 544              		.loc 1 463 14 is_stmt 0 view .LVU132
 545 0000 0B4A     		ldr	r2, .L38
 546 0002 0023     		movs	r3, #0
 547 0004 1380     		strh	r3, [r2]	@ movhi
 464:Src/util.c    ****     #if defined(MOTOR_LEFT_ENA)
 465:Src/util.c    ****       #if defined(INVERT_L_DIRECTION)
 466:Src/util.c    ****         speedAvg -= rtY_Left.n_mot;
 467:Src/util.c    ****       #else
 468:Src/util.c    ****         speedAvg += rtY_Left.n_mot;
 548              		.loc 1 468 9 is_stmt 1 view .LVU133
 549              		.loc 1 468 29 is_stmt 0 view .LVU134
 550 0006 0B4B     		ldr	r3, .L38+4
 551 0008 B3F90810 		ldrsh	r1, [r3, #8]
 552 000c 8BB2     		uxth	r3, r1
 553              		.loc 1 468 18 view .LVU135
 554 000e 1180     		strh	r1, [r2]	@ movhi
 469:Src/util.c    ****       #endif
 470:Src/util.c    ****     #endif
 471:Src/util.c    ****     #if defined(MOTOR_RIGHT_ENA)
 472:Src/util.c    ****       #if defined(INVERT_R_DIRECTION)
 473:Src/util.c    ****         speedAvg += rtY_Right.n_mot;
 474:Src/util.c    ****       #else
 475:Src/util.c    ****         speedAvg -= rtY_Right.n_mot;
 555              		.loc 1 475 9 is_stmt 1 view .LVU136
 556              		.loc 1 475 30 is_stmt 0 view .LVU137
 557 0010 0949     		ldr	r1, .L38+8
ARM GAS  /tmp/ccQoOasm.s 			page 19


 558 0012 0989     		ldrh	r1, [r1, #8]
 559              		.loc 1 475 18 view .LVU138
 560 0014 5B1A     		subs	r3, r3, r1
 561 0016 1BB2     		sxth	r3, r3
 562 0018 1380     		strh	r3, [r2]	@ movhi
 476:Src/util.c    ****       #endif
 477:Src/util.c    **** 
 478:Src/util.c    ****       // Average only if both motors are enabled
 479:Src/util.c    ****       #if defined(MOTOR_LEFT_ENA)
 480:Src/util.c    ****         speedAvg /= 2;
 563              		.loc 1 480 9 is_stmt 1 view .LVU139
 564              		.loc 1 480 18 is_stmt 0 view .LVU140
 565 001a 03EBD373 		add	r3, r3, r3, lsr #31
 566 001e 5B10     		asrs	r3, r3, #1
 567 0020 1380     		strh	r3, [r2]	@ movhi
 481:Src/util.c    ****       #endif  
 482:Src/util.c    ****     #endif
 483:Src/util.c    **** 
 484:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
 485:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 568              		.loc 1 485 5 is_stmt 1 view .LVU141
 486:Src/util.c    ****       speedAvg    = -speedAvg;
 487:Src/util.c    ****     } 
 488:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 569              		.loc 1 488 5 view .LVU142
 570              		.loc 1 488 21 is_stmt 0 view .LVU143
 571 0022 002B     		cmp	r3, #0
 572 0024 B8BF     		it	lt
 573 0026 5B42     		rsblt	r3, r3, #0
 574              		.loc 1 488 19 view .LVU144
 575 0028 044A     		ldr	r2, .L38+12
 576 002a 1380     		strh	r3, [r2]	@ movhi
 489:Src/util.c    **** }
 577              		.loc 1 489 1 view .LVU145
 578 002c 7047     		bx	lr
 579              	.L39:
 580 002e 00BF     		.align	2
 581              	.L38:
 582 0030 00000000 		.word	speedAvg
 583 0034 00000000 		.word	rtY_Left
 584 0038 00000000 		.word	rtY_Right
 585 003c 00000000 		.word	speedAvgAbs
 586              		.cfi_endproc
 587              	.LFE75:
 589              		.section	.text.adcCalibLim,"ax",%progbits
 590              		.align	1
 591              		.global	adcCalibLim
 592              		.syntax unified
 593              		.thumb
 594              		.thumb_func
 596              	adcCalibLim:
 597              	.LFB76:
 490:Src/util.c    **** 
 491:Src/util.c    ****  /*
 492:Src/util.c    ****  * Auto-calibration of the ADC Limits
 493:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 494:Src/util.c    ****  * Procedure:
ARM GAS  /tmp/ccQoOasm.s 			page 20


 495:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 496:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
 497:Src/util.c    ****  * - release potentiometers to the resting postion
 498:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 499:Src/util.c    ****  * The Values will be saved to flash. Values are persistent if you flash with platformio. To erase 
 500:Src/util.c    ****  */
 501:Src/util.c    **** void adcCalibLim(void) {
 598              		.loc 1 501 24 is_stmt 1 view -0
 599              		.cfi_startproc
 600              		@ args = 0, pretend = 0, frame = 0
 601              		@ frame_needed = 0, uses_anonymous_args = 0
 602              		@ link register save eliminated.
 502:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 503:Src/util.c    ****   calcAvgSpeed();
 504:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 505:Src/util.c    ****     return;
 506:Src/util.c    ****   }
 507:Src/util.c    **** 
 508:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 509:Src/util.c    **** 
 510:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 511:Src/util.c    ****   printf("Input calibration started...\r\n");
 512:Src/util.c    ****   #endif
 513:Src/util.c    **** 
 514:Src/util.c    ****   readInputRaw();
 515:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 516:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 517:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 518:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 519:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 520:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 521:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 522:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 523:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 524:Src/util.c    ****   int16_t  input_margin    = 0;
 525:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 526:Src/util.c    ****   
 527:Src/util.c    ****   #ifdef CONTROL_ADC
 528:Src/util.c    ****   if (inIdx == CONTROL_ADC) {
 529:Src/util.c    ****     input_margin = ADC_MARGIN;
 530:Src/util.c    ****   }
 531:Src/util.c    ****   #endif
 532:Src/util.c    **** 
 533:Src/util.c    ****   // Extract MIN, MAX and MID from ADC while the power button is not pressed
 534:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && input_cal_timeout++ < 4000) {   // 20 sec ti
 535:Src/util.c    ****     readInputRaw();
 536:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 537:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 538:Src/util.c    ****     
 539:Src/util.c    ****     INPUT1_MID_temp = (int16_t)(input1_fixdt >> 16);// CLAMP(input1_fixdt >> 16, INPUT1_MIN, INPUT1
 540:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 541:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 542:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 543:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 544:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 545:Src/util.c    ****     HAL_Delay(5);
 546:Src/util.c    ****   }
ARM GAS  /tmp/ccQoOasm.s 			page 21


 547:Src/util.c    **** 
 548:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 549:Src/util.c    ****   printf("Input1 is ");
 550:Src/util.c    ****   #endif
 551:Src/util.c    ****   uint8_t input1TypTemp = checkInputType(INPUT1_MIN_temp, INPUT1_MID_temp, INPUT1_MAX_temp);
 552:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 553:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 554:Src/util.c    ****     printf("..OK\r\n");
 555:Src/util.c    ****     #endif
 556:Src/util.c    ****   } else {
 557:Src/util.c    ****     input1TypTemp = 0; // Disable input
 558:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 559:Src/util.c    ****     printf("..NOK\r\n");
 560:Src/util.c    ****     #endif
 561:Src/util.c    ****   }
 562:Src/util.c    **** 
 563:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 564:Src/util.c    ****   printf("Input2 is ");
 565:Src/util.c    ****   #endif
 566:Src/util.c    ****   uint8_t input2TypTemp = checkInputType(INPUT2_MIN_temp, INPUT2_MID_temp, INPUT2_MAX_temp);
 567:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 568:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 569:Src/util.c    ****     printf("..OK\r\n");
 570:Src/util.c    ****     #endif
 571:Src/util.c    ****   } else {
 572:Src/util.c    ****     input2TypTemp = 0; // Disable input
 573:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 574:Src/util.c    ****     printf("..NOK\r\n");
 575:Src/util.c    ****     #endif
 576:Src/util.c    ****   }
 577:Src/util.c    **** 
 578:Src/util.c    **** 
 579:Src/util.c    ****   // At least one of the inputs is not ignored
 580:Src/util.c    ****   if (input1TypTemp != 0 || input2TypTemp != 0){
 581:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 582:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 583:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 584:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 585:Src/util.c    **** 
 586:Src/util.c    ****     input2[inIdx].typ = input2TypTemp;
 587:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 588:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 589:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 590:Src/util.c    **** 
 591:Src/util.c    ****     inp_cal_valid = 1;    // Mark calibration to be saved in Flash at shutdown
 592:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 593:Src/util.c    ****     printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i MAX:%
 594:Src/util.c    ****             input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 595:Src/util.c    ****             input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 596:Src/util.c    ****     #endif
 597:Src/util.c    ****   }else{
 598:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 599:Src/util.c    ****     printf("Both inputs cannot be ignored, calibration rejected.\r\n");
 600:Src/util.c    ****     #endif
 601:Src/util.c    ****   }
 602:Src/util.c    **** 
 603:Src/util.c    **** #endif
ARM GAS  /tmp/ccQoOasm.s 			page 22


 604:Src/util.c    **** #endif  // AUTO_CALIBRATION_ENA
 605:Src/util.c    **** }
 603              		.loc 1 605 1 view .LVU147
 604 0000 7047     		bx	lr
 605              		.cfi_endproc
 606              	.LFE76:
 608              		.section	.text.standstillHold,"ax",%progbits
 609              		.align	1
 610              		.global	standstillHold
 611              		.syntax unified
 612              		.thumb
 613              		.thumb_func
 615              	standstillHold:
 616              	.LFB78:
 606:Src/util.c    ****  /*
 607:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 608:Src/util.c    ****  * Procedure:
 609:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 610:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
 611:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 612:Src/util.c    ****  */
 613:Src/util.c    **** void updateCurSpdLim(void) {
 614:Src/util.c    ****   calcAvgSpeed();
 615:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 616:Src/util.c    ****     return;
 617:Src/util.c    ****   }
 618:Src/util.c    **** 
 619:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 620:Src/util.c    **** 
 621:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 622:Src/util.c    ****   printf("Torque and Speed limits update started...\r\n");
 623:Src/util.c    ****   #endif
 624:Src/util.c    **** 
 625:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 626:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 627:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 628:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 629:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 630:Src/util.c    ****   cur_spd_valid = 0;
 631:Src/util.c    **** 
 632:Src/util.c    ****   // Wait for the power button press
 633:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec timeo
 634:Src/util.c    ****     readInputRaw();
 635:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 636:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 637:Src/util.c    ****     HAL_Delay(5);
 638:Src/util.c    ****   }
 639:Src/util.c    ****   // Calculate scaling factors
 640:Src/util.c    ****   cur_factor = CLAMP((input1_fixdt - (input1[inIdx].min << 16)) / (input1[inIdx].max - input1[inIdx
 641:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 642:Src/util.c    ****       
 643:Src/util.c    ****   if (input1[inIdx].typ != 0){
 644:Src/util.c    ****     // Update current limit
 645:Src/util.c    ****     rtP_Left.i_max = rtP_Right.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    
 646:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 647:Src/util.c    ****   }
 648:Src/util.c    **** 
ARM GAS  /tmp/ccQoOasm.s 			page 23


 649:Src/util.c    ****   if (input2[inIdx].typ != 0){
 650:Src/util.c    ****     // Update speed limit
 651:Src/util.c    ****     rtP_Left.n_max = rtP_Right.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 
 652:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 653:Src/util.c    ****   }
 654:Src/util.c    **** 
 655:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 656:Src/util.c    ****   // cur_spd_valid: 0 = No limit changed, 1 = Current limit changed, 2 = Speed limit changed, 3 = B
 657:Src/util.c    ****   printf("Limits (%i)\r\nCurrent: fixdt:%li factor%i i_max:%i \r\nSpeed: fixdt:%li factor:%i n_max:
 658:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 659:Src/util.c    ****   #endif
 660:Src/util.c    **** 
 661:Src/util.c    **** #endif
 662:Src/util.c    **** }
 663:Src/util.c    **** 
 664:Src/util.c    ****  /*
 665:Src/util.c    ****  * Standstill Hold Function
 666:Src/util.c    ****  * This function uses Cruise Control to provide an anti-roll functionality at standstill.
 667:Src/util.c    ****  * Only available and makes sense for FOC VOLTAGE or FOC TORQUE mode.
 668:Src/util.c    ****  * 
 669:Src/util.c    ****  * Input:  none
 670:Src/util.c    ****  * Output: standstillAcv
 671:Src/util.c    ****  */
 672:Src/util.c    **** void standstillHold(void) {
 617              		.loc 1 672 27 view -0
 618              		.cfi_startproc
 619              		@ args = 0, pretend = 0, frame = 0
 620              		@ frame_needed = 0, uses_anonymous_args = 0
 621              		@ link register save eliminated.
 673:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
 674:Src/util.c    ****     if (!rtP_Left.b_cruiseCtrlEna) {                                  // If Stanstill in NOT Active
 675:Src/util.c    ****       if (((input1[inIdx].cmd > 50 || input2[inIdx].cmd < -50) && speedAvgAbs < 30) // Check if Bra
 676:Src/util.c    ****           || (input2[inIdx].cmd < 20 && speedAvgAbs < 5)) {           // OR Throttle is small AND m
 677:Src/util.c    ****         rtP_Left.n_cruiseMotTgt   = 0;
 678:Src/util.c    ****         rtP_Right.n_cruiseMotTgt  = 0;
 679:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 1;
 680:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 1;
 681:Src/util.c    ****         standstillAcv = 1;
 682:Src/util.c    ****       } 
 683:Src/util.c    ****     }
 684:Src/util.c    ****     else {                                                            // If Stanstill is Active -> 
 685:Src/util.c    ****       if (input1[inIdx].cmd < 20 && input2[inIdx].cmd > 50 && !cruiseCtrlAcv) { // Check if Brake i
 686:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 0;
 687:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 0;
 688:Src/util.c    ****         standstillAcv = 0;
 689:Src/util.c    ****       }
 690:Src/util.c    ****     }
 691:Src/util.c    ****   #endif
 692:Src/util.c    **** }
 622              		.loc 1 692 1 view .LVU149
 623 0000 7047     		bx	lr
 624              		.cfi_endproc
 625              	.LFE78:
 627              		.section	.text.electricBrake,"ax",%progbits
 628              		.align	1
 629              		.global	electricBrake
 630              		.syntax unified
ARM GAS  /tmp/ccQoOasm.s 			page 24


 631              		.thumb
 632              		.thumb_func
 634              	electricBrake:
 635              	.LVL28:
 636              	.LFB79:
 693:Src/util.c    **** 
 694:Src/util.c    ****  /*
 695:Src/util.c    ****  * Electric Brake Function
 696:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 697:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 698:Src/util.c    ****  * 
 699:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 700:Src/util.c    ****  * Output: input2.cmd (Throtle) with brake component included
 701:Src/util.c    ****  */
 702:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 637              		.loc 1 702 61 view -0
 638              		.cfi_startproc
 639              		@ args = 0, pretend = 0, frame = 0
 640              		@ frame_needed = 0, uses_anonymous_args = 0
 641              		@ link register save eliminated.
 703:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 704:Src/util.c    ****     int16_t brakeVal;
 705:Src/util.c    **** 
 706:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 707:Src/util.c    ****     if (speedAvg > 0) {
 708:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 709:Src/util.c    ****     } else {
 710:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 711:Src/util.c    ****     }
 712:Src/util.c    **** 
 713:Src/util.c    ****     // Check if direction is reversed
 714:Src/util.c    ****     if (reverseDir) {
 715:Src/util.c    ****       brakeVal = -brakeVal;
 716:Src/util.c    ****     }
 717:Src/util.c    **** 
 718:Src/util.c    ****     // Calculate the new input2.cmd with brake component included
 719:Src/util.c    ****     if (input2[inIdx].cmd >= 0 && input2[inIdx].cmd < ELECTRIC_BRAKE_THRES) {
 720:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - input2[inIdx].cmd) * brakeVal) / E
 721:Src/util.c    ****     } else if (input2[inIdx].cmd >= -ELECTRIC_BRAKE_THRES && input2[inIdx].cmd < 0) {
 722:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + input2[inIdx].cmd) * brakeVal) / E
 723:Src/util.c    ****     } else if (input2[inIdx].cmd >= ELECTRIC_BRAKE_THRES) {
 724:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((input2[inIdx].cmd - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / 
 725:Src/util.c    ****     } else {  // when (input2.cmd < -ELECTRIC_BRAKE_THRES)
 726:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((input2[inIdx].cmd + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / 
 727:Src/util.c    ****     }
 728:Src/util.c    ****   #endif
 729:Src/util.c    **** }
 642              		.loc 1 729 1 view .LVU151
 643 0000 7047     		bx	lr
 644              		.cfi_endproc
 645              	.LFE79:
 647              		.section	.text.cruiseControl,"ax",%progbits
 648              		.align	1
 649              		.global	cruiseControl
 650              		.syntax unified
 651              		.thumb
 652              		.thumb_func
ARM GAS  /tmp/ccQoOasm.s 			page 25


 654              	cruiseControl:
 655              	.LVL29:
 656              	.LFB80:
 730:Src/util.c    **** 
 731:Src/util.c    ****  /*
 732:Src/util.c    ****  * Cruise Control Function
 733:Src/util.c    ****  * This function activates/deactivates cruise control.
 734:Src/util.c    ****  * 
 735:Src/util.c    ****  * Input: button (as a pulse)
 736:Src/util.c    ****  * Output: cruiseCtrlAcv
 737:Src/util.c    ****  */
 738:Src/util.c    **** void cruiseControl(uint8_t button) {
 657              		.loc 1 738 36 view -0
 658              		.cfi_startproc
 659              		@ args = 0, pretend = 0, frame = 0
 660              		@ frame_needed = 0, uses_anonymous_args = 0
 661              		@ link register save eliminated.
 739:Src/util.c    ****   #ifdef CRUISE_CONTROL_SUPPORT
 740:Src/util.c    ****     if (button && !rtP_Left.b_cruiseCtrlEna) {                          // Cruise control activated
 741:Src/util.c    ****       rtP_Left.n_cruiseMotTgt   = rtY_Left.n_mot;
 742:Src/util.c    ****       rtP_Right.n_cruiseMotTgt  = rtY_Right.n_mot;
 743:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 1;
 744:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 1;
 745:Src/util.c    ****       cruiseCtrlAcv = 1;
 746:Src/util.c    ****       beepShortMany(2, 1);                                              // 200 ms beep delay. Acts 
 747:Src/util.c    ****     } else if (button && rtP_Left.b_cruiseCtrlEna && !standstillAcv) {  // Cruise control deactivat
 748:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 0;
 749:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 0;
 750:Src/util.c    ****       cruiseCtrlAcv = 0;
 751:Src/util.c    ****       beepShortMany(2, -1);
 752:Src/util.c    ****     }
 753:Src/util.c    ****   #endif
 754:Src/util.c    **** }
 662              		.loc 1 754 1 view .LVU153
 663 0000 7047     		bx	lr
 664              		.cfi_endproc
 665              	.LFE80:
 667              		.section	.text.checkInputType,"ax",%progbits
 668              		.align	1
 669              		.global	checkInputType
 670              		.syntax unified
 671              		.thumb
 672              		.thumb_func
 674              	checkInputType:
 675              	.LVL30:
 676              	.LFB81:
 755:Src/util.c    **** 
 756:Src/util.c    ****  /*
 757:Src/util.c    ****  * Check Input Type
 758:Src/util.c    ****  * This function identifies the input type: 0: Disabled, 1: Normal Pot, 2: Middle Resting Pot
 759:Src/util.c    ****  */
 760:Src/util.c    **** int checkInputType(int16_t min, int16_t mid, int16_t max){
 677              		.loc 1 760 58 view -0
 678              		.cfi_startproc
 679              		@ args = 0, pretend = 0, frame = 0
 680              		@ frame_needed = 0, uses_anonymous_args = 0
 681              		.loc 1 760 58 is_stmt 0 view .LVU155
ARM GAS  /tmp/ccQoOasm.s 			page 26


 682 0000 10B5     		push	{r4, lr}
 683              	.LCFI5:
 684              		.cfi_def_cfa_offset 8
 685              		.cfi_offset 4, -8
 686              		.cfi_offset 14, -4
 761:Src/util.c    **** 
 762:Src/util.c    ****   int type = 0;  
 687              		.loc 1 762 3 is_stmt 1 view .LVU156
 688              	.LVL31:
 763:Src/util.c    ****   #ifdef CONTROL_ADC
 764:Src/util.c    ****   int16_t threshold = 400;      // Threshold to define if values are too close
 765:Src/util.c    ****   #else
 766:Src/util.c    ****   int16_t threshold = 200;
 689              		.loc 1 766 3 view .LVU157
 767:Src/util.c    ****   #endif
 768:Src/util.c    **** 
 769:Src/util.c    ****   if ((min / threshold) == (max / threshold) || (mid / threshold) == (max / threshold) || min > max
 690              		.loc 1 769 3 view .LVU158
 691              		.loc 1 769 12 is_stmt 0 view .LVU159
 692 0002 154B     		ldr	r3, .L53
 693 0004 83FB00C4 		smull	ip, r4, r3, r0
 694 0008 4FEAE07E 		asr	lr, r0, #31
 695 000c CEEBA41E 		rsb	lr, lr, r4, asr #6
 696              		.loc 1 769 33 view .LVU160
 697 0010 83FB0243 		smull	r4, r3, r3, r2
 698 0014 4FEAE27C 		asr	ip, r2, #31
 699 0018 CCEBA313 		rsb	r3, ip, r3, asr #6
 700              		.loc 1 769 6 view .LVU161
 701 001c 9E45     		cmp	lr, r3
 702 001e 12D0     		beq	.L46
 703              		.loc 1 769 54 discriminator 1 view .LVU162
 704 0020 0D4C     		ldr	r4, .L53
 705 0022 84FB01C4 		smull	ip, r4, r4, r1
 706 0026 4FEAE17C 		asr	ip, r1, #31
 707 002a CCEBA41C 		rsb	ip, ip, r4, asr #6
 708              		.loc 1 769 46 discriminator 1 view .LVU163
 709 002e 6345     		cmp	r3, ip
 710 0030 0BD0     		beq	.L47
 711              		.loc 1 769 88 discriminator 2 view .LVU164
 712 0032 9042     		cmp	r0, r2
 713 0034 0BDC     		bgt	.L48
 714              		.loc 1 769 101 discriminator 3 view .LVU165
 715 0036 8A42     		cmp	r2, r1
 716 0038 0BDB     		blt	.L49
 770:Src/util.c    ****     type = 0;
 771:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 772:Src/util.c    ****     printf("ignored");                // (MIN and MAX) OR (MID and MAX) are close, disable input
 773:Src/util.c    ****     #endif
 774:Src/util.c    ****   } else {
 775:Src/util.c    ****     if ((min / threshold) == (mid / threshold)){
 717              		.loc 1 775 5 is_stmt 1 view .LVU166
 718              		.loc 1 775 8 is_stmt 0 view .LVU167
 719 003a E645     		cmp	lr, ip
 720 003c 01D0     		beq	.L52
 776:Src/util.c    ****       type = 1;
 777:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 778:Src/util.c    ****       printf("a normal pot");        // MIN and MID are close, it's a normal pot
ARM GAS  /tmp/ccQoOasm.s 			page 27


 779:Src/util.c    ****       #endif
 780:Src/util.c    ****     } else {
 781:Src/util.c    ****       type = 2;
 721              		.loc 1 781 12 view .LVU168
 722 003e 0220     		movs	r0, #2
 723              	.LVL32:
 782:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 783:Src/util.c    ****       printf("a mid-resting pot");   // it's a mid resting pot
 784:Src/util.c    ****       #endif
 785:Src/util.c    ****     }
 786:Src/util.c    **** 
 787:Src/util.c    ****     #ifdef CONTROL_ADC
 788:Src/util.c    ****     if ((min + ADC_MARGIN - ADC_PROTECT_THRESH) > 0 && (max - ADC_MARGIN + ADC_PROTECT_THRESH) < 40
 789:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 790:Src/util.c    ****       printf(" AND protected");
 791:Src/util.c    ****       #endif
 792:Src/util.c    ****       beepLong(2); // Indicate protection by a beep
 793:Src/util.c    ****     }
 794:Src/util.c    ****     #endif
 795:Src/util.c    ****   }
 796:Src/util.c    **** 
 797:Src/util.c    ****   return type;
 724              		.loc 1 797 3 is_stmt 1 view .LVU169
 725              		.loc 1 797 10 is_stmt 0 view .LVU170
 726 0040 02E0     		b	.L44
 727              	.LVL33:
 728              	.L52:
 776:Src/util.c    ****       type = 1;
 729              		.loc 1 776 12 view .LVU171
 730 0042 0120     		movs	r0, #1
 731              	.LVL34:
 776:Src/util.c    ****       type = 1;
 732              		.loc 1 776 12 view .LVU172
 733 0044 00E0     		b	.L44
 734              	.LVL35:
 735              	.L46:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 736              		.loc 1 770 10 view .LVU173
 737 0046 0020     		movs	r0, #0
 738              	.LVL36:
 739              	.L44:
 798:Src/util.c    **** }
 740              		.loc 1 798 1 view .LVU174
 741 0048 10BD     		pop	{r4, pc}
 742              	.LVL37:
 743              	.L47:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 744              		.loc 1 770 10 view .LVU175
 745 004a 0020     		movs	r0, #0
 746              	.LVL38:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 747              		.loc 1 770 10 view .LVU176
 748 004c FCE7     		b	.L44
 749              	.LVL39:
 750              	.L48:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 751              		.loc 1 770 10 view .LVU177
ARM GAS  /tmp/ccQoOasm.s 			page 28


 752 004e 0020     		movs	r0, #0
 753              	.LVL40:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 754              		.loc 1 770 10 view .LVU178
 755 0050 FAE7     		b	.L44
 756              	.LVL41:
 757              	.L49:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 758              		.loc 1 770 10 view .LVU179
 759 0052 0020     		movs	r0, #0
 760              	.LVL42:
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 761              		.loc 1 770 10 view .LVU180
 762 0054 F8E7     		b	.L44
 763              	.L54:
 764 0056 00BF     		.align	2
 765              	.L53:
 766 0058 1F85EB51 		.word	1374389535
 767              		.cfi_endproc
 768              	.LFE81:
 770              		.section	.rodata.Input_Init.str1.4,"aMS",%progbits,1
 771              		.align	2
 772              	.LC0:
 773 0000 4C696D69 		.ascii	"Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\015\012L"
 773      74732049 
 773      6E707574 
 773      313A2054 
 773      59503A25 
 774 002d 696D6974 		.ascii	"imits Input2: TYP:%i MIN:%i MID:%i MAX:%i\015\012\000"
 774      7320496E 
 774      70757432 
 774      3A205459 
 774      503A2569 
 775              		.section	.text.Input_Init,"ax",%progbits
 776              		.align	1
 777              		.global	Input_Init
 778              		.syntax unified
 779              		.thumb
 780              		.thumb_func
 782              	Input_Init:
 783              	.LFB68:
 277:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 784              		.loc 1 277 23 is_stmt 1 view -0
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 8
 787              		@ frame_needed = 0, uses_anonymous_args = 0
 788 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 789              	.LCFI6:
 790              		.cfi_def_cfa_offset 32
 791              		.cfi_offset 4, -32
 792              		.cfi_offset 5, -28
 793              		.cfi_offset 6, -24
 794              		.cfi_offset 7, -20
 795              		.cfi_offset 8, -16
 796              		.cfi_offset 9, -12
 797              		.cfi_offset 10, -8
 798              		.cfi_offset 14, -4
ARM GAS  /tmp/ccQoOasm.s 			page 29


 799 0004 88B0     		sub	sp, sp, #32
 800              	.LCFI7:
 801              		.cfi_def_cfa_offset 64
 287:Src/util.c    ****   #endif
 802              		.loc 1 287 5 view .LVU182
 803 0006 FFF7FEFF 		bl	UART2_Init
 804              	.LVL43:
 293:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 805              		.loc 1 293 5 view .LVU183
 806 000a 844C     		ldr	r4, .L70
 807 000c 4022     		movs	r2, #64
 808 000e 8449     		ldr	r1, .L70+4
 809 0010 2046     		mov	r0, r4
 810 0012 FFF7FEFF 		bl	HAL_UART_Receive_DMA
 811              	.LVL44:
 294:Src/util.c    ****   #endif
 812              		.loc 1 294 5 view .LVU184
 813 0016 2046     		mov	r0, r4
 814 0018 FFF7FEFF 		bl	UART_DisableRxErrors
 815              	.LVL45:
 302:Src/util.c    ****     HAL_FLASH_Unlock();
 816              		.loc 1 302 5 view .LVU185
 303:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 817              		.loc 1 303 5 view .LVU186
 818 001c FFF7FEFF 		bl	HAL_FLASH_Unlock
 819              	.LVL46:
 304:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 820              		.loc 1 304 5 view .LVU187
 821 0020 FFF7FEFF 		bl	EE_Init
 822              	.LVL47:
 305:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 823              		.loc 1 305 5 view .LVU188
 824 0024 0DF11E01 		add	r1, sp, #30
 825 0028 7E4B     		ldr	r3, .L70+8
 826 002a 1888     		ldrh	r0, [r3]
 827 002c FFF7FEFF 		bl	EE_ReadVariable
 828              	.LVL48:
 306:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 829              		.loc 1 306 5 view .LVU189
 306:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 830              		.loc 1 306 20 is_stmt 0 view .LVU190
 831 0030 BDF81E20 		ldrh	r2, [sp, #30]
 306:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 832              		.loc 1 306 8 view .LVU191
 833 0034 41F20203 		movw	r3, #4098
 834 0038 9A42     		cmp	r2, r3
 835 003a 01D0     		beq	.L67
 836              	.LBB5:
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 837              		.loc 1 332 20 view .LVU192
 838 003c 0025     		movs	r5, #0
 839 003e CBE0     		b	.L56
 840              	.L67:
 841              	.LBE5:
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 842              		.loc 1 311 7 is_stmt 1 view .LVU193
 843 0040 784E     		ldr	r6, .L70+8
ARM GAS  /tmp/ccQoOasm.s 			page 30


 844 0042 07A9     		add	r1, sp, #28
 845 0044 7088     		ldrh	r0, [r6, #2]
 846 0046 FFF7FEFF 		bl	EE_ReadVariable
 847              	.LVL49:
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 848              		.loc 1 311 53 discriminator 1 view .LVU194
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 849              		.loc 1 311 88 is_stmt 0 discriminator 1 view .LVU195
 850 004a BDF91C30 		ldrsh	r3, [sp, #28]
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 851              		.loc 1 311 86 discriminator 1 view .LVU196
 852 004e 764D     		ldr	r5, .L70+12
 853 0050 A5F8CE30 		strh	r3, [r5, #206]	@ movhi
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 854              		.loc 1 311 68 discriminator 1 view .LVU197
 855 0054 754C     		ldr	r4, .L70+16
 856 0056 A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 857              		.loc 1 312 7 is_stmt 1 view .LVU198
 858 005a 07A9     		add	r1, sp, #28
 859 005c B088     		ldrh	r0, [r6, #4]
 860 005e FFF7FEFF 		bl	EE_ReadVariable
 861              	.LVL50:
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 862              		.loc 1 312 53 discriminator 1 view .LVU199
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 863              		.loc 1 312 88 is_stmt 0 discriminator 1 view .LVU200
 864 0062 BDF91C30 		ldrsh	r3, [sp, #28]
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 865              		.loc 1 312 86 discriminator 1 view .LVU201
 866 0066 A5F8DA30 		strh	r3, [r5, #218]	@ movhi
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 867              		.loc 1 312 68 discriminator 1 view .LVU202
 868 006a A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 869              		.loc 1 313 7 is_stmt 1 view .LVU203
 870              	.LBB6:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 871              		.loc 1 313 12 view .LVU204
 872              	.LVL51:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 873              		.loc 1 313 20 is_stmt 0 view .LVU205
 874 006e 0026     		movs	r6, #0
 875              	.LVL52:
 876              	.L57:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 877              		.loc 1 313 26 is_stmt 1 discriminator 1 view .LVU206
 878 0070 002E     		cmp	r6, #0
 879 0072 40F0B380 		bne	.L59
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 880              		.loc 1 314 9 view .LVU207
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 881              		.loc 1 314 43 is_stmt 0 view .LVU208
 882 0076 F400     		lsls	r4, r6, #3
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 883              		.loc 1 314 41 view .LVU209
 884 0078 E31C     		adds	r3, r4, #3
ARM GAS  /tmp/ccQoOasm.s 			page 31


 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 885              		.loc 1 314 9 view .LVU210
 886 007a DFF8A881 		ldr	r8, .L70+8
 887 007e 07A9     		add	r1, sp, #28
 888 0080 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 889 0084 FFF7FEFF 		bl	EE_ReadVariable
 890              	.LVL53:
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 891              		.loc 1 314 60 is_stmt 1 discriminator 1 view .LVU211
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 892              		.loc 1 314 76 is_stmt 0 discriminator 1 view .LVU212
 893 0088 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 894              		.loc 1 314 74 discriminator 1 view .LVU213
 895 008c A21B     		subs	r2, r4, r6
 896 008e 684D     		ldr	r5, .L70+20
 897 0090 05EB4205 		add	r5, r5, r2, lsl #1
 898 0094 2B71     		strb	r3, [r5, #4]
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 899              		.loc 1 315 9 is_stmt 1 view .LVU214
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 900              		.loc 1 315 41 is_stmt 0 view .LVU215
 901 0096 231D     		adds	r3, r4, #4
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 902              		.loc 1 315 9 view .LVU216
 903 0098 07A9     		add	r1, sp, #28
 904 009a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 905 009e FFF7FEFF 		bl	EE_ReadVariable
 906              	.LVL54:
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 907              		.loc 1 315 60 is_stmt 1 discriminator 1 view .LVU217
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 908              		.loc 1 315 76 is_stmt 0 discriminator 1 view .LVU218
 909 00a2 BDF91C30 		ldrsh	r3, [sp, #28]
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 910              		.loc 1 315 74 discriminator 1 view .LVU219
 911 00a6 EB80     		strh	r3, [r5, #6]	@ movhi
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 912              		.loc 1 316 9 is_stmt 1 view .LVU220
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 913              		.loc 1 316 41 is_stmt 0 view .LVU221
 914 00a8 631D     		adds	r3, r4, #5
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 915              		.loc 1 316 9 view .LVU222
 916 00aa 07A9     		add	r1, sp, #28
 917 00ac 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 918 00b0 FFF7FEFF 		bl	EE_ReadVariable
 919              	.LVL55:
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 920              		.loc 1 316 60 is_stmt 1 discriminator 1 view .LVU223
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 921              		.loc 1 316 76 is_stmt 0 discriminator 1 view .LVU224
 922 00b4 BDF91C30 		ldrsh	r3, [sp, #28]
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 923              		.loc 1 316 74 discriminator 1 view .LVU225
 924 00b8 2B81     		strh	r3, [r5, #8]	@ movhi
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
ARM GAS  /tmp/ccQoOasm.s 			page 32


 925              		.loc 1 317 9 is_stmt 1 view .LVU226
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 926              		.loc 1 317 41 is_stmt 0 view .LVU227
 927 00ba A31D     		adds	r3, r4, #6
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 928              		.loc 1 317 9 view .LVU228
 929 00bc 07A9     		add	r1, sp, #28
 930 00be 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 931 00c2 FFF7FEFF 		bl	EE_ReadVariable
 932              	.LVL56:
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 933              		.loc 1 317 60 is_stmt 1 discriminator 1 view .LVU229
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 934              		.loc 1 317 76 is_stmt 0 discriminator 1 view .LVU230
 935 00c6 BDF91C30 		ldrsh	r3, [sp, #28]
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 936              		.loc 1 317 74 discriminator 1 view .LVU231
 937 00ca 6B81     		strh	r3, [r5, #10]	@ movhi
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 938              		.loc 1 318 9 is_stmt 1 view .LVU232
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 939              		.loc 1 318 41 is_stmt 0 view .LVU233
 940 00cc E31D     		adds	r3, r4, #7
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 941              		.loc 1 318 9 view .LVU234
 942 00ce 07A9     		add	r1, sp, #28
 943 00d0 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 944 00d4 FFF7FEFF 		bl	EE_ReadVariable
 945              	.LVL57:
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 946              		.loc 1 318 60 is_stmt 1 discriminator 1 view .LVU235
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 947              		.loc 1 318 76 is_stmt 0 discriminator 1 view .LVU236
 948 00d8 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 949              		.loc 1 318 74 discriminator 1 view .LVU237
 950 00dc DFF85491 		ldr	r9, .L70+24
 951 00e0 A71B     		subs	r7, r4, r6
 952 00e2 09EB4707 		add	r7, r9, r7, lsl #1
 953 00e6 3B71     		strb	r3, [r7, #4]
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 954              		.loc 1 319 9 is_stmt 1 view .LVU238
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 955              		.loc 1 319 41 is_stmt 0 view .LVU239
 956 00e8 06F1010A 		add	r10, r6, #1
 957 00ec 4FEACA03 		lsl	r3, r10, #3
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 958              		.loc 1 319 9 view .LVU240
 959 00f0 07A9     		add	r1, sp, #28
 960 00f2 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 961 00f6 FFF7FEFF 		bl	EE_ReadVariable
 962              	.LVL58:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 963              		.loc 1 319 60 is_stmt 1 discriminator 1 view .LVU241
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 964              		.loc 1 319 76 is_stmt 0 discriminator 1 view .LVU242
 965 00fa BDF91C30 		ldrsh	r3, [sp, #28]
ARM GAS  /tmp/ccQoOasm.s 			page 33


 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 966              		.loc 1 319 74 discriminator 1 view .LVU243
 967 00fe FB80     		strh	r3, [r7, #6]	@ movhi
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 968              		.loc 1 320 9 is_stmt 1 view .LVU244
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 969              		.loc 1 320 41 is_stmt 0 view .LVU245
 970 0100 04F10903 		add	r3, r4, #9
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 971              		.loc 1 320 9 view .LVU246
 972 0104 07A9     		add	r1, sp, #28
 973 0106 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 974 010a FFF7FEFF 		bl	EE_ReadVariable
 975              	.LVL59:
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 976              		.loc 1 320 60 is_stmt 1 discriminator 1 view .LVU247
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 977              		.loc 1 320 76 is_stmt 0 discriminator 1 view .LVU248
 978 010e BDF91C30 		ldrsh	r3, [sp, #28]
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 979              		.loc 1 320 74 discriminator 1 view .LVU249
 980 0112 3B81     		strh	r3, [r7, #8]	@ movhi
 321:Src/util.c    ****       
 981              		.loc 1 321 9 is_stmt 1 view .LVU250
 321:Src/util.c    ****       
 982              		.loc 1 321 41 is_stmt 0 view .LVU251
 983 0114 04F10A03 		add	r3, r4, #10
 321:Src/util.c    ****       
 984              		.loc 1 321 9 view .LVU252
 985 0118 07A9     		add	r1, sp, #28
 986 011a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 987 011e FFF7FEFF 		bl	EE_ReadVariable
 988              	.LVL60:
 321:Src/util.c    ****       
 989              		.loc 1 321 60 is_stmt 1 discriminator 1 view .LVU253
 321:Src/util.c    ****       
 990              		.loc 1 321 76 is_stmt 0 discriminator 1 view .LVU254
 991 0122 BDF91C30 		ldrsh	r3, [sp, #28]
 321:Src/util.c    ****       
 992              		.loc 1 321 74 discriminator 1 view .LVU255
 993 0126 7B81     		strh	r3, [r7, #10]	@ movhi
 323:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 994              		.loc 1 323 9 is_stmt 1 view .LVU256
 324:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 995              		.loc 1 324 65 is_stmt 0 view .LVU257
 996 0128 B5F90A20 		ldrsh	r2, [r5, #10]
 325:Src/util.c    ****       }
 997              		.loc 1 325 20 view .LVU258
 998 012c 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 325:Src/util.c    ****       }
 999              		.loc 1 325 35 view .LVU259
 1000 012e B7F90600 		ldrsh	r0, [r7, #6]
 325:Src/util.c    ****       }
 1001              		.loc 1 325 50 view .LVU260
 1002 0132 B7F90840 		ldrsh	r4, [r7, #8]
 323:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1003              		.loc 1 323 9 view .LVU261
ARM GAS  /tmp/ccQoOasm.s 			page 34


 1004 0136 0493     		str	r3, [sp, #16]
 1005 0138 0394     		str	r4, [sp, #12]
 1006 013a 0290     		str	r0, [sp, #8]
 1007 013c 0191     		str	r1, [sp, #4]
 1008 013e 0092     		str	r2, [sp]
 1009 0140 B5F90830 		ldrsh	r3, [r5, #8]
 1010 0144 B5F90620 		ldrsh	r2, [r5, #6]
 1011 0148 2979     		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 1012 014a 3B48     		ldr	r0, .L70+28
 1013 014c FFF7FEFF 		bl	printf
 1014              	.LVL61:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1015              		.loc 1 313 39 is_stmt 1 discriminator 3 view .LVU262
 1016 0150 5FFA8AF6 		uxtb	r6, r10
 1017              	.LVL62:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1018              		.loc 1 313 39 is_stmt 0 discriminator 3 view .LVU263
 1019 0154 8CE7     		b	.L57
 1020              	.LVL63:
 1021              	.L64:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1022              		.loc 1 313 39 discriminator 3 view .LVU264
 1023              	.LBE6:
 1024              	.LBB7:
 333:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1025              		.loc 1 333 9 is_stmt 1 view .LVU265
 333:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1026              		.loc 1 333 22 is_stmt 0 view .LVU266
 1027 0156 2C46     		mov	r4, r5
 1028 0158 C5EBC502 		rsb	r2, r5, r5, lsl #3
 1029 015c 344B     		ldr	r3, .L70+20
 1030 015e 03EB4203 		add	r3, r3, r2, lsl #1
 1031 0162 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 333:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1032              		.loc 1 333 12 view .LVU267
 1033 0164 032B     		cmp	r3, #3
 1034 0166 3ED0     		beq	.L68
 336:Src/util.c    ****         }
 1035              		.loc 1 336 11 is_stmt 1 view .LVU268
 336:Src/util.c    ****         }
 1036              		.loc 1 336 25 is_stmt 0 view .LVU269
 1037 0168 C5EBC501 		rsb	r1, r5, r5, lsl #3
 1038 016c 304A     		ldr	r2, .L70+20
 1039 016e 02EB4102 		add	r2, r2, r1, lsl #1
 1040 0172 1371     		strb	r3, [r2, #4]
 1041              	.L61:
 338:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1042              		.loc 1 338 9 is_stmt 1 view .LVU270
 338:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1043              		.loc 1 338 22 is_stmt 0 view .LVU271
 1044 0174 C4EBC402 		rsb	r2, r4, r4, lsl #3
 1045 0178 2E4B     		ldr	r3, .L70+24
 1046 017a 03EB4203 		add	r3, r3, r2, lsl #1
 1047 017e 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 338:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1048              		.loc 1 338 12 view .LVU272
 1049 0180 032B     		cmp	r3, #3
ARM GAS  /tmp/ccQoOasm.s 			page 35


 1050 0182 3DD0     		beq	.L69
 341:Src/util.c    ****         }
 1051              		.loc 1 341 11 is_stmt 1 view .LVU273
 341:Src/util.c    ****         }
 1052              		.loc 1 341 25 is_stmt 0 view .LVU274
 1053 0184 C4EBC401 		rsb	r1, r4, r4, lsl #3
 1054 0188 2A4A     		ldr	r2, .L70+24
 1055 018a 02EB4102 		add	r2, r2, r1, lsl #1
 1056 018e 1371     		strb	r3, [r2, #4]
 1057              	.L63:
 343:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1058              		.loc 1 343 9 is_stmt 1 view .LVU275
 344:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1059              		.loc 1 344 20 is_stmt 0 view .LVU276
 1060 0190 C4EBC403 		rsb	r3, r4, r4, lsl #3
 1061 0194 2649     		ldr	r1, .L70+20
 1062 0196 01EB4301 		add	r1, r1, r3, lsl #1
 344:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1063              		.loc 1 344 65 view .LVU277
 1064 019a B1F90A00 		ldrsh	r0, [r1, #10]
 345:Src/util.c    ****       }
 1065              		.loc 1 345 20 view .LVU278
 1066 019e 254A     		ldr	r2, .L70+24
 1067 01a0 02EB4303 		add	r3, r2, r3, lsl #1
 1068 01a4 1E79     		ldrb	r6, [r3, #4]	@ zero_extendqisi2
 345:Src/util.c    ****       }
 1069              		.loc 1 345 35 view .LVU279
 1070 01a6 B3F90670 		ldrsh	r7, [r3, #6]
 345:Src/util.c    ****       }
 1071              		.loc 1 345 50 view .LVU280
 1072 01aa B3F90830 		ldrsh	r3, [r3, #8]
 345:Src/util.c    ****       }
 1073              		.loc 1 345 65 view .LVU281
 1074 01ae C4EBC404 		rsb	r4, r4, r4, lsl #3
 1075 01b2 02EB4402 		add	r2, r2, r4, lsl #1
 1076 01b6 B2F90A20 		ldrsh	r2, [r2, #10]
 343:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1077              		.loc 1 343 9 view .LVU282
 1078 01ba 0492     		str	r2, [sp, #16]
 1079 01bc 0393     		str	r3, [sp, #12]
 1080 01be 0297     		str	r7, [sp, #8]
 1081 01c0 0196     		str	r6, [sp, #4]
 1082 01c2 0090     		str	r0, [sp]
 1083 01c4 B1F90830 		ldrsh	r3, [r1, #8]
 1084 01c8 B1F90620 		ldrsh	r2, [r1, #6]
 1085 01cc 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 1086 01ce 1A48     		ldr	r0, .L70+28
 1087 01d0 FFF7FEFF 		bl	printf
 1088              	.LVL64:
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1089              		.loc 1 332 39 is_stmt 1 discriminator 2 view .LVU283
 1090 01d4 0135     		adds	r5, r5, #1
 1091              	.LVL65:
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1092              		.loc 1 332 39 is_stmt 0 discriminator 2 view .LVU284
 1093 01d6 EDB2     		uxtb	r5, r5
 1094              	.LVL66:
ARM GAS  /tmp/ccQoOasm.s 			page 36


 1095              	.L56:
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1096              		.loc 1 332 26 is_stmt 1 discriminator 1 view .LVU285
 1097 01d8 002D     		cmp	r5, #0
 1098 01da BCD0     		beq	.L64
 1099              	.LVL67:
 1100              	.L59:
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1101              		.loc 1 332 26 is_stmt 0 discriminator 1 view .LVU286
 1102              	.LBE7:
 348:Src/util.c    ****   #endif
 1103              		.loc 1 348 5 is_stmt 1 view .LVU287
 1104 01dc FFF7FEFF 		bl	HAL_FLASH_Lock
 1105              	.LVL68:
 400:Src/util.c    **** 
 1106              		.loc 1 400 1 is_stmt 0 view .LVU288
 1107 01e0 08B0     		add	sp, sp, #32
 1108              	.LCFI8:
 1109              		.cfi_remember_state
 1110              		.cfi_def_cfa_offset 32
 1111              		@ sp needed
 1112 01e2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1113              	.LVL69:
 1114              	.L68:
 1115              	.LCFI9:
 1116              		.cfi_restore_state
 1117              	.LBB8:
 334:Src/util.c    ****         } else {
 1118              		.loc 1 334 11 is_stmt 1 view .LVU289
 334:Src/util.c    ****         } else {
 1119              		.loc 1 334 27 is_stmt 0 view .LVU290
 1120 01e6 124E     		ldr	r6, .L70+20
 1121 01e8 06EB4206 		add	r6, r6, r2, lsl #1
 1122 01ec B6F90A20 		ldrsh	r2, [r6, #10]
 1123 01f0 B6F90810 		ldrsh	r1, [r6, #8]
 1124 01f4 B6F90600 		ldrsh	r0, [r6, #6]
 1125 01f8 FFF7FEFF 		bl	checkInputType
 1126              	.LVL70:
 334:Src/util.c    ****         } else {
 1127              		.loc 1 334 25 discriminator 1 view .LVU291
 1128 01fc 3071     		strb	r0, [r6, #4]
 1129 01fe B9E7     		b	.L61
 1130              	.L69:
 339:Src/util.c    ****         } else {
 1131              		.loc 1 339 11 is_stmt 1 view .LVU292
 339:Src/util.c    ****         } else {
 1132              		.loc 1 339 27 is_stmt 0 view .LVU293
 1133 0200 0C4E     		ldr	r6, .L70+24
 1134 0202 06EB4206 		add	r6, r6, r2, lsl #1
 1135 0206 B6F90A20 		ldrsh	r2, [r6, #10]
 1136 020a B6F90810 		ldrsh	r1, [r6, #8]
 1137 020e B6F90600 		ldrsh	r0, [r6, #6]
 1138 0212 FFF7FEFF 		bl	checkInputType
 1139              	.LVL71:
 339:Src/util.c    ****         } else {
 1140              		.loc 1 339 25 discriminator 1 view .LVU294
 1141 0216 3071     		strb	r0, [r6, #4]
ARM GAS  /tmp/ccQoOasm.s 			page 37


 1142 0218 BAE7     		b	.L63
 1143              	.L71:
 1144 021a 00BF     		.align	2
 1145              	.L70:
 1146 021c 00000000 		.word	huart2
 1147 0220 00000000 		.word	rx_buffer_L
 1148 0224 00000000 		.word	VirtAddVarTab
 1149 0228 00000000 		.word	rtP_Right
 1150 022c 00000000 		.word	rtP_Left
 1151 0230 00000000 		.word	input1
 1152 0234 00000000 		.word	input2
 1153 0238 00000000 		.word	.LC0
 1154              	.LBE8:
 1155              		.cfi_endproc
 1156              	.LFE68:
 1158              		.section	.text.calcInputCmd,"ax",%progbits
 1159              		.align	1
 1160              		.global	calcInputCmd
 1161              		.syntax unified
 1162              		.thumb
 1163              		.thumb_func
 1165              	calcInputCmd:
 1166              	.LVL72:
 1167              	.LFB82:
 799:Src/util.c    **** 
 800:Src/util.c    **** 
 801:Src/util.c    **** 
 802:Src/util.c    **** /* =========================== Input Functions =========================== */
 803:Src/util.c    **** 
 804:Src/util.c    ****  /*
 805:Src/util.c    ****  * Calculate Input Command
 806:Src/util.c    ****  * This function realizes dead-band around 0 and scales the input between [out_min, out_max]
 807:Src/util.c    ****  */
 808:Src/util.c    **** void calcInputCmd(InputStruct *in, int16_t out_min, int16_t out_max) {
 1168              		.loc 1 808 70 is_stmt 1 view -0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 0
 1171              		@ frame_needed = 0, uses_anonymous_args = 0
 809:Src/util.c    ****   switch (in->typ){
 1172              		.loc 1 809 3 view .LVU296
 1173              		.loc 1 809 13 is_stmt 0 view .LVU297
 1174 0000 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 1175              		.loc 1 809 3 view .LVU298
 1176 0002 012B     		cmp	r3, #1
 1177 0004 04D0     		beq	.L73
 1178 0006 022B     		cmp	r3, #2
 1179 0008 17D0     		beq	.L74
 810:Src/util.c    ****     case 1: // Input is a normal pot
 811:Src/util.c    ****       in->cmd = CLAMP(MAP(in->raw, in->min, in->max, 0, out_max), 0, out_max);
 812:Src/util.c    ****       break;
 813:Src/util.c    ****     case 2: // Input is a mid resting pot
 814:Src/util.c    ****       if( in->raw > in->mid - in->dband && in->raw < in->mid + in->dband ) {
 815:Src/util.c    ****         in->cmd = 0;
 816:Src/util.c    ****       } else if(in->raw > in->mid) {
 817:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 818:Src/util.c    ****       } else {
 819:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid - in->dband, in->min, 0, out_min), out_min, 0);
ARM GAS  /tmp/ccQoOasm.s 			page 38


 820:Src/util.c    ****       }
 821:Src/util.c    ****       break;
 822:Src/util.c    ****     default: // Input is ignored
 823:Src/util.c    ****       in->cmd = 0;
 1180              		.loc 1 823 7 is_stmt 1 view .LVU299
 1181              		.loc 1 823 15 is_stmt 0 view .LVU300
 1182 000a 0023     		movs	r3, #0
 1183 000c 4380     		strh	r3, [r0, #2]	@ movhi
 824:Src/util.c    ****       break;
 1184              		.loc 1 824 7 is_stmt 1 view .LVU301
 1185 000e 7047     		bx	lr
 1186              	.L73:
 811:Src/util.c    ****       break;
 1187              		.loc 1 811 7 view .LVU302
 811:Src/util.c    ****       break;
 1188              		.loc 1 811 17 is_stmt 0 view .LVU303
 1189 0010 B0F90030 		ldrsh	r3, [r0]
 1190 0014 B0F906C0 		ldrsh	ip, [r0, #6]
 1191 0018 A3EB0C03 		sub	r3, r3, ip
 1192 001c 02FB03F3 		mul	r3, r2, r3
 1193 0020 B0F90A10 		ldrsh	r1, [r0, #10]
 1194              	.LVL73:
 811:Src/util.c    ****       break;
 1195              		.loc 1 811 17 view .LVU304
 1196 0024 A1EB0C01 		sub	r1, r1, ip
 1197 0028 93FBF1F3 		sdiv	r3, r3, r1
 811:Src/util.c    ****       break;
 1198              		.loc 1 811 15 view .LVU305
 1199 002c 9A42     		cmp	r2, r3
 1200 002e 02DB     		blt	.L76
 811:Src/util.c    ****       break;
 1201              		.loc 1 811 17 discriminator 1 view .LVU306
 1202 0030 23EAE373 		bic	r3, r3, r3, asr #31
 811:Src/util.c    ****       break;
 1203              		.loc 1 811 15 discriminator 1 view .LVU307
 1204 0034 1AB2     		sxth	r2, r3
 1205              	.LVL74:
 1206              	.L76:
 811:Src/util.c    ****       break;
 1207              		.loc 1 811 15 discriminator 4 view .LVU308
 1208 0036 4280     		strh	r2, [r0, #2]	@ movhi
 812:Src/util.c    ****     case 2: // Input is a mid resting pot
 1209              		.loc 1 812 7 is_stmt 1 view .LVU309
 1210 0038 7047     		bx	lr
 1211              	.LVL75:
 1212              	.L74:
 808:Src/util.c    ****   switch (in->typ){
 1213              		.loc 1 808 70 is_stmt 0 view .LVU310
 1214 003a 30B5     		push	{r4, r5, lr}
 1215              	.LCFI10:
 1216              		.cfi_def_cfa_offset 12
 1217              		.cfi_offset 4, -12
 1218              		.cfi_offset 5, -8
 1219              		.cfi_offset 14, -4
 814:Src/util.c    ****         in->cmd = 0;
 1220              		.loc 1 814 7 is_stmt 1 view .LVU311
 814:Src/util.c    ****         in->cmd = 0;
ARM GAS  /tmp/ccQoOasm.s 			page 39


 1221              		.loc 1 814 13 is_stmt 0 view .LVU312
 1222 003c B0F90030 		ldrsh	r3, [r0]
 814:Src/util.c    ****         in->cmd = 0;
 1223              		.loc 1 814 23 view .LVU313
 1224 0040 B0F908C0 		ldrsh	ip, [r0, #8]
 814:Src/util.c    ****         in->cmd = 0;
 1225              		.loc 1 814 33 view .LVU314
 1226 0044 B0F90CE0 		ldrsh	lr, [r0, #12]
 814:Src/util.c    ****         in->cmd = 0;
 1227              		.loc 1 814 29 view .LVU315
 1228 0048 ACEB0E04 		sub	r4, ip, lr
 814:Src/util.c    ****         in->cmd = 0;
 1229              		.loc 1 814 9 view .LVU316
 1230 004c A342     		cmp	r3, r4
 1231 004e 06DD     		ble	.L78
 814:Src/util.c    ****         in->cmd = 0;
 1232              		.loc 1 814 62 discriminator 1 view .LVU317
 1233 0050 0CEB0E05 		add	r5, ip, lr
 814:Src/util.c    ****         in->cmd = 0;
 1234              		.loc 1 814 41 discriminator 1 view .LVU318
 1235 0054 AB42     		cmp	r3, r5
 1236 0056 02DA     		bge	.L78
 815:Src/util.c    ****       } else if(in->raw > in->mid) {
 1237              		.loc 1 815 9 is_stmt 1 view .LVU319
 815:Src/util.c    ****       } else if(in->raw > in->mid) {
 1238              		.loc 1 815 17 is_stmt 0 view .LVU320
 1239 0058 0023     		movs	r3, #0
 1240 005a 4380     		strh	r3, [r0, #2]	@ movhi
 1241 005c 12E0     		b	.L72
 1242              	.L78:
 816:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1243              		.loc 1 816 14 is_stmt 1 view .LVU321
 816:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1244              		.loc 1 816 16 is_stmt 0 view .LVU322
 1245 005e 6345     		cmp	r3, ip
 1246 0060 11DD     		ble	.L79
 817:Src/util.c    ****       } else {
 1247              		.loc 1 817 9 is_stmt 1 view .LVU323
 817:Src/util.c    ****       } else {
 1248              		.loc 1 817 19 is_stmt 0 view .LVU324
 1249 0062 F444     		add	ip, ip, lr
 1250 0064 A3EB0C03 		sub	r3, r3, ip
 1251 0068 02FB03F3 		mul	r3, r2, r3
 1252 006c B0F90A10 		ldrsh	r1, [r0, #10]
 1253              	.LVL76:
 817:Src/util.c    ****       } else {
 1254              		.loc 1 817 19 view .LVU325
 1255 0070 A1EB0C01 		sub	r1, r1, ip
 1256 0074 93FBF1F3 		sdiv	r3, r3, r1
 817:Src/util.c    ****       } else {
 1257              		.loc 1 817 17 view .LVU326
 1258 0078 9A42     		cmp	r2, r3
 1259 007a 02DB     		blt	.L80
 817:Src/util.c    ****       } else {
 1260              		.loc 1 817 19 discriminator 1 view .LVU327
 1261 007c 23EAE373 		bic	r3, r3, r3, asr #31
 817:Src/util.c    ****       } else {
ARM GAS  /tmp/ccQoOasm.s 			page 40


 1262              		.loc 1 817 17 discriminator 1 view .LVU328
 1263 0080 1AB2     		sxth	r2, r3
 1264              	.LVL77:
 1265              	.L80:
 817:Src/util.c    ****       } else {
 1266              		.loc 1 817 17 discriminator 4 view .LVU329
 1267 0082 4280     		strh	r2, [r0, #2]	@ movhi
 1268              	.L72:
 825:Src/util.c    ****   }
 826:Src/util.c    **** }
 1269              		.loc 1 826 1 view .LVU330
 1270 0084 30BD     		pop	{r4, r5, pc}
 1271              	.LVL78:
 1272              	.L79:
 819:Src/util.c    ****       }
 1273              		.loc 1 819 9 is_stmt 1 view .LVU331
 819:Src/util.c    ****       }
 1274              		.loc 1 819 19 is_stmt 0 view .LVU332
 1275 0086 1B1B     		subs	r3, r3, r4
 1276 0088 01FB03F3 		mul	r3, r1, r3
 1277 008c B0F90620 		ldrsh	r2, [r0, #6]
 1278              	.LVL79:
 819:Src/util.c    ****       }
 1279              		.loc 1 819 19 view .LVU333
 1280 0090 121B     		subs	r2, r2, r4
 1281 0092 93FBF2F3 		sdiv	r3, r3, r2
 819:Src/util.c    ****       }
 1282              		.loc 1 819 17 view .LVU334
 1283 0096 002B     		cmp	r3, #0
 1284 0098 02DD     		ble	.L87
 819:Src/util.c    ****       }
 1285              		.loc 1 819 17 discriminator 2 view .LVU335
 1286 009a 0021     		movs	r1, #0
 1287              	.LVL80:
 1288              	.L81:
 819:Src/util.c    ****       }
 1289              		.loc 1 819 17 discriminator 4 view .LVU336
 1290 009c 4180     		strh	r1, [r0, #2]	@ movhi
 1291 009e F1E7     		b	.L72
 1292              	.LVL81:
 1293              	.L87:
 819:Src/util.c    ****       }
 1294              		.loc 1 819 19 discriminator 1 view .LVU337
 1295 00a0 9942     		cmp	r1, r3
 1296 00a2 B8BF     		it	lt
 1297 00a4 1946     		movlt	r1, r3
 1298              	.LVL82:
 819:Src/util.c    ****       }
 1299              		.loc 1 819 17 discriminator 1 view .LVU338
 1300 00a6 09B2     		sxth	r1, r1
 1301 00a8 F8E7     		b	.L81
 1302              		.cfi_endproc
 1303              	.LFE82:
 1305              		.section	.text.readInputRaw,"ax",%progbits
 1306              		.align	1
 1307              		.global	readInputRaw
 1308              		.syntax unified
ARM GAS  /tmp/ccQoOasm.s 			page 41


 1309              		.thumb
 1310              		.thumb_func
 1312              	readInputRaw:
 1313              	.LFB83:
 827:Src/util.c    **** 
 828:Src/util.c    ****  /*
 829:Src/util.c    ****  * Function to read the Input Raw values from various input devices
 830:Src/util.c    ****  */
 831:Src/util.c    **** void readInputRaw(void) {
 1314              		.loc 1 831 25 is_stmt 1 view -0
 1315              		.cfi_startproc
 1316              		@ args = 0, pretend = 0, frame = 0
 1317              		@ frame_needed = 0, uses_anonymous_args = 0
 1318              		@ link register save eliminated.
 832:Src/util.c    ****     #ifdef CONTROL_ADC
 833:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 834:Src/util.c    ****       #ifdef ADC_ALTERNATE_CONNECT
 835:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_rx2;
 836:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_tx2;
 837:Src/util.c    ****       #else
 838:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_tx2;
 839:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_rx2;
 840:Src/util.c    ****       #endif
 841:Src/util.c    ****     }
 842:Src/util.c    ****     #endif
 843:Src/util.c    **** 
 844:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 845:Src/util.c    ****     if (Nunchuk_Read() == NUNCHUK_CONNECTED) {
 846:Src/util.c    ****       if (inIdx == CONTROL_NUNCHUK) {
 847:Src/util.c    ****         input1[inIdx].raw = (nunchuk_data[0] - 127) * 8; // X axis 0-255
 848:Src/util.c    ****         input2[inIdx].raw = (nunchuk_data[1] - 128) * 8; // Y axis 0-255
 849:Src/util.c    ****       }
 850:Src/util.c    ****       #ifdef SUPPORT_BUTTONS
 851:Src/util.c    ****         button1 = (uint8_t)nunchuk_data[5] & 1;
 852:Src/util.c    ****         button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
 853:Src/util.c    ****       #endif
 854:Src/util.c    ****     }
 855:Src/util.c    ****     #endif
 856:Src/util.c    **** 
 857:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2)
 858:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART2) {
 1319              		.loc 1 858 5 view .LVU340
 1320              		.loc 1 858 15 is_stmt 0 view .LVU341
 1321 0000 094B     		ldr	r3, .L90
 1322 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1323              		.loc 1 858 8 view .LVU342
 1324 0004 7BB9     		cbnz	r3, .L88
 859:Src/util.c    ****       #ifdef CONTROL_IBUS
 860:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 861:Src/util.c    ****           ibusL_captured_value[(i/2)] = CLAMP(commandL.channels[i] + (commandL.channels[i+1] << 8) 
 862:Src/util.c    ****         }
 863:Src/util.c    ****         input1[inIdx].raw = (ibusL_captured_value[0] - 500) * 2;
 864:Src/util.c    ****         input2[inIdx].raw = (ibusL_captured_value[1] - 500) * 2; 
 865:Src/util.c    ****       #else
 866:Src/util.c    ****         input1[inIdx].raw = commandL.steer;
 1325              		.loc 1 866 9 is_stmt 1 view .LVU343
 1326              		.loc 1 866 37 is_stmt 0 view .LVU344
ARM GAS  /tmp/ccQoOasm.s 			page 42


 1327 0006 094A     		ldr	r2, .L90+4
 1328 0008 B2F902C0 		ldrsh	ip, [r2, #2]
 1329              		.loc 1 866 27 view .LVU345
 1330 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1331 0010 4100     		lsls	r1, r0, #1
 1332 0012 0748     		ldr	r0, .L90+8
 1333 0014 20F801C0 		strh	ip, [r0, r1]	@ movhi
 867:Src/util.c    ****         input2[inIdx].raw = commandL.speed;
 1334              		.loc 1 867 9 is_stmt 1 view .LVU346
 1335              		.loc 1 867 37 is_stmt 0 view .LVU347
 1336 0018 B2F90410 		ldrsh	r1, [r2, #4]
 1337              		.loc 1 867 27 view .LVU348
 1338 001c C3EBC303 		rsb	r3, r3, r3, lsl #3
 1339 0020 5A00     		lsls	r2, r3, #1
 1340 0022 044B     		ldr	r3, .L90+12
 1341 0024 9952     		strh	r1, [r3, r2]	@ movhi
 1342              	.L88:
 868:Src/util.c    ****       #endif
 869:Src/util.c    ****     }
 870:Src/util.c    ****     #endif
 871:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3)
 872:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART3) {
 873:Src/util.c    ****       #ifdef CONTROL_IBUS
 874:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 875:Src/util.c    ****           ibusR_captured_value[(i/2)] = CLAMP(commandR.channels[i] + (commandR.channels[i+1] << 8) 
 876:Src/util.c    ****         }
 877:Src/util.c    ****         input1[inIdx].raw = (ibusR_captured_value[0] - 500) * 2;
 878:Src/util.c    ****         input2[inIdx].raw = (ibusR_captured_value[1] - 500) * 2; 
 879:Src/util.c    ****       #else
 880:Src/util.c    ****         input1[inIdx].raw = commandR.steer;
 881:Src/util.c    ****         input2[inIdx].raw = commandR.speed;
 882:Src/util.c    ****       #endif
 883:Src/util.c    ****     }
 884:Src/util.c    ****     #endif
 885:Src/util.c    **** 
 886:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 887:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
 888:Src/util.c    ****       input1[inIdx].raw = Sideboard_L.cmd1;
 889:Src/util.c    ****       input2[inIdx].raw = Sideboard_L.cmd2;
 890:Src/util.c    ****     }
 891:Src/util.c    ****     #endif
 892:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
 893:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
 894:Src/util.c    ****       input1[inIdx].raw = Sideboard_R.cmd1;
 895:Src/util.c    ****       input2[inIdx].raw = Sideboard_R.cmd2;
 896:Src/util.c    ****     }
 897:Src/util.c    ****     #endif
 898:Src/util.c    **** 
 899:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT)
 900:Src/util.c    ****     if (inIdx == CONTROL_PPM_LEFT) {
 901:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 902:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 903:Src/util.c    ****     }
 904:Src/util.c    ****     #endif
 905:Src/util.c    ****     #if defined(CONTROL_PPM_RIGHT)
 906:Src/util.c    ****     if (inIdx == CONTROL_PPM_RIGHT) {
 907:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
ARM GAS  /tmp/ccQoOasm.s 			page 43


 908:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 909:Src/util.c    ****     }
 910:Src/util.c    ****     #endif
 911:Src/util.c    ****     #if (defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)) && defined(SUPPORT_BUTTONS)
 912:Src/util.c    ****       button1 = ppm_captured_value[5] > 500;
 913:Src/util.c    ****       button2 = 0;
 914:Src/util.c    ****     #endif
 915:Src/util.c    **** 
 916:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT)
 917:Src/util.c    ****     if (inIdx == CONTROL_PWM_LEFT) {
 918:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 919:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 920:Src/util.c    ****     }
 921:Src/util.c    ****     #endif
 922:Src/util.c    ****     #if defined(CONTROL_PWM_RIGHT)
 923:Src/util.c    ****     if (inIdx == CONTROL_PWM_RIGHT) {
 924:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 925:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 926:Src/util.c    ****     }
 927:Src/util.c    ****     #endif
 928:Src/util.c    **** 
 929:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 930:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 931:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_rx2;
 932:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_tx2;
 933:Src/util.c    ****       #endif
 934:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 935:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_tx2;
 936:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_rx2;
 937:Src/util.c    ****       #endif
 938:Src/util.c    ****     #endif
 939:Src/util.c    **** }
 1343              		.loc 1 939 1 view .LVU349
 1344 0026 7047     		bx	lr
 1345              	.L91:
 1346              		.align	2
 1347              	.L90:
 1348 0028 00000000 		.word	inIdx
 1349 002c 00000000 		.word	commandL
 1350 0030 00000000 		.word	input1
 1351 0034 00000000 		.word	input2
 1352              		.cfi_endproc
 1353              	.LFE83:
 1355              		.section	.text.handleTimeout,"ax",%progbits
 1356              		.align	1
 1357              		.global	handleTimeout
 1358              		.syntax unified
 1359              		.thumb
 1360              		.thumb_func
 1362              	handleTimeout:
 1363              	.LFB84:
 940:Src/util.c    **** 
 941:Src/util.c    ****  /*
 942:Src/util.c    ****  * Function to handle the ADC, UART and General timeout (Nunchuk, PPM, PWM)
 943:Src/util.c    ****  */
 944:Src/util.c    **** void handleTimeout(void) {
 1364              		.loc 1 944 26 is_stmt 1 view -0
ARM GAS  /tmp/ccQoOasm.s 			page 44


 1365              		.cfi_startproc
 1366              		@ args = 0, pretend = 0, frame = 0
 1367              		@ frame_needed = 0, uses_anonymous_args = 0
 1368 0000 08B5     		push	{r3, lr}
 1369              	.LCFI11:
 1370              		.cfi_def_cfa_offset 8
 1371              		.cfi_offset 3, -8
 1372              		.cfi_offset 14, -4
 945:Src/util.c    ****     #ifdef CONTROL_ADC
 946:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 947:Src/util.c    ****       // If input1 or Input2 is either below MIN - Threshold or above MAX + Threshold, ADC protecti
 948:Src/util.c    ****       if (IN_RANGE(input1[inIdx].raw, input1[inIdx].min - ADC_PROTECT_THRESH, input1[inIdx].max + A
 949:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 950:Src/util.c    ****           timeoutFlgADC = 0;                            // Reset the timeout flag
 951:Src/util.c    ****           timeoutCntADC = 0;                            // Reset the timeout counter
 952:Src/util.c    ****       } else {
 953:Src/util.c    ****         if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) {   // Timeout qualification
 954:Src/util.c    ****           timeoutFlgADC = 1;                            // Timeout detected
 955:Src/util.c    ****           timeoutCntADC = ADC_PROTECT_TIMEOUT;          // Limit timout counter value
 956:Src/util.c    ****         }
 957:Src/util.c    ****       }
 958:Src/util.c    ****     }
 959:Src/util.c    ****     #endif
 960:Src/util.c    **** 
 961:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 962:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 1373              		.loc 1 962 7 view .LVU351
 1374              		.loc 1 962 29 is_stmt 0 view .LVU352
 1375 0002 1E4A     		ldr	r2, .L102
 1376 0004 1388     		ldrh	r3, [r2]
 1377 0006 591C     		adds	r1, r3, #1
 1378 0008 1180     		strh	r1, [r2]	@ movhi
 1379              		.loc 1 962 10 view .LVU353
 1380 000a 9F2B     		cmp	r3, #159
 1381 000c 05D9     		bls	.L93
 963:Src/util.c    ****         timeoutFlgSerial_L = 1;                         // Timeout detected
 1382              		.loc 1 963 9 is_stmt 1 view .LVU354
 1383              		.loc 1 963 28 is_stmt 0 view .LVU355
 1384 000e 1C4B     		ldr	r3, .L102+4
 1385 0010 0122     		movs	r2, #1
 1386 0012 1A70     		strb	r2, [r3]
 964:Src/util.c    ****         timeoutCntSerial_L = SERIAL_TIMEOUT;            // Limit timout counter value
 1387              		.loc 1 964 9 is_stmt 1 view .LVU356
 1388              		.loc 1 964 28 is_stmt 0 view .LVU357
 1389 0014 194B     		ldr	r3, .L102
 1390 0016 A022     		movs	r2, #160
 1391 0018 1A80     		strh	r2, [r3]	@ movhi
 1392              	.L93:
 965:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1)
 966:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 967:Src/util.c    ****         #endif
 968:Src/util.c    ****       } else {                                          // No Timeout
 969:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
 970:Src/util.c    ****           if (Sideboard_L.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 971:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART2;
 972:Src/util.c    ****           } else {
 973:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART2;
ARM GAS  /tmp/ccQoOasm.s 			page 45


 974:Src/util.c    ****           }
 975:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1
 976:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 977:Src/util.c    ****         #endif
 978:Src/util.c    ****       }
 1393              		.loc 1 978 7 is_stmt 1 view .LVU358
 979:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 0) || (defined(SIDEBOARD_SERI
 980:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_L;          // Report Timeout only on the Primary Input
 1394              		.loc 1 980 9 view .LVU359
 1395              		.loc 1 980 26 is_stmt 0 view .LVU360
 1396 001a 194B     		ldr	r3, .L102+4
 1397 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1398 001e 194A     		ldr	r2, .L102+8
 1399 0020 1370     		strb	r3, [r2]
 981:Src/util.c    ****       #endif
 982:Src/util.c    ****     #endif
 983:Src/util.c    **** 
 984:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 985:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 986:Src/util.c    ****         timeoutFlgSerial_R = 1;                         // Timeout detected
 987:Src/util.c    ****         timeoutCntSerial_R = SERIAL_TIMEOUT;            // Limit timout counter value
 988:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1)
 989:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 990:Src/util.c    ****         #endif
 991:Src/util.c    ****       } else {                                          // No Timeout
 992:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
 993:Src/util.c    ****           if (Sideboard_R.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 994:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART3;
 995:Src/util.c    ****           } else {
 996:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART3;
 997:Src/util.c    ****           }
 998:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1
 999:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1000:Src/util.c    ****         #endif
1001:Src/util.c    ****       }
1002:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 0) || (defined(SIDEBOARD_SERI
1003:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_R;          // Report Timeout only on the Primary Input
1004:Src/util.c    ****       #endif
1005:Src/util.c    ****     #endif
1006:Src/util.c    **** 
1007:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
1008:Src/util.c    ****       timeoutFlgSerial = timeoutFlgSerial_L || timeoutFlgSerial_R;
1009:Src/util.c    ****     #endif
1010:Src/util.c    **** 
1011:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) || \
1012:Src/util.c    ****         defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || def
1013:Src/util.c    ****       if (timeoutCntGen++ >= TIMEOUT) {                 // Timeout qualification
1014:Src/util.c    ****         #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) ||
1015:Src/util.c    ****             (defined(CONTROL_PPM_LEFT) && CONTROL_PPM_LEFT == 0) || (defined(CONTROL_PPM_RIGHT) && 
1016:Src/util.c    ****             (defined(CONTROL_PWM_LEFT) && CONTROL_PWM_LEFT == 0) || (defined(CONTROL_PWM_RIGHT) && 
1017:Src/util.c    ****           timeoutFlgGen = 1;                            // Report Timeout only on the Primary Input
1018:Src/util.c    ****           timeoutCntGen = TIMEOUT;
1019:Src/util.c    ****         #endif
1020:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1021:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1022:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
1023:Src/util.c    ****         #endif
ARM GAS  /tmp/ccQoOasm.s 			page 46


1024:Src/util.c    ****       } else {
1025:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1026:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1027:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1028:Src/util.c    ****         #endif
1029:Src/util.c    ****       }
1030:Src/util.c    ****     #endif
1031:Src/util.c    **** 
1032:Src/util.c    ****     // In case of timeout bring the system to a Safe State
1033:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial || timeoutFlgGen) {
 1400              		.loc 1 1033 5 is_stmt 1 view .LVU361
 1401              		.loc 1 1033 9 is_stmt 0 view .LVU362
 1402 0022 194A     		ldr	r2, .L102+12
 1403 0024 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1404              		.loc 1 1033 8 view .LVU363
 1405 0026 1AB9     		cbnz	r2, .L94
 1406              		.loc 1 1033 23 discriminator 1 view .LVU364
 1407 0028 13B9     		cbnz	r3, .L94
 1408              		.loc 1 1033 43 discriminator 2 view .LVU365
 1409 002a 184B     		ldr	r3, .L102+16
 1410 002c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1411 002e C3B1     		cbz	r3, .L95
 1412              	.L94:
1034:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 1413              		.loc 1 1034 7 is_stmt 1 view .LVU366
 1414              		.loc 1 1034 19 is_stmt 0 view .LVU367
 1415 0030 0022     		movs	r2, #0
 1416 0032 174B     		ldr	r3, .L102+20
 1417 0034 1A70     		strb	r2, [r3]
1035:Src/util.c    ****       input1[inIdx].cmd  = 0;
 1418              		.loc 1 1035 7 is_stmt 1 view .LVU368
 1419              		.loc 1 1035 20 is_stmt 0 view .LVU369
 1420 0036 174B     		ldr	r3, .L102+24
 1421 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1422              		.loc 1 1035 26 view .LVU370
 1423 003a C3EBC301 		rsb	r1, r3, r3, lsl #3
 1424 003e 4800     		lsls	r0, r1, #1
 1425 0040 1549     		ldr	r1, .L102+28
 1426 0042 0144     		add	r1, r1, r0
 1427 0044 4A80     		strh	r2, [r1, #2]	@ movhi
1036:Src/util.c    ****       input2[inIdx].cmd  = 0;
 1428              		.loc 1 1036 7 is_stmt 1 view .LVU371
 1429              		.loc 1 1036 26 is_stmt 0 view .LVU372
 1430 0046 154B     		ldr	r3, .L102+32
 1431 0048 0344     		add	r3, r3, r0
 1432 004a 5A80     		strh	r2, [r3, #2]	@ movhi
 1433              	.L96:
1037:Src/util.c    ****     } else {
1038:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
1039:Src/util.c    ****     }
1040:Src/util.c    **** 
1041:Src/util.c    ****     // Beep in case of Input index change
1042:Src/util.c    ****     if (inIdx && !inIdx_prev) {                                         // rising edge
 1434              		.loc 1 1042 5 is_stmt 1 view .LVU373
 1435              		.loc 1 1042 9 is_stmt 0 view .LVU374
 1436 004c 114B     		ldr	r3, .L102+24
 1437 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  /tmp/ccQoOasm.s 			page 47


 1438              		.loc 1 1042 8 view .LVU375
 1439 0050 13B1     		cbz	r3, .L97
 1440              		.loc 1 1042 18 discriminator 1 view .LVU376
 1441 0052 134A     		ldr	r2, .L102+36
 1442 0054 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1443              		.loc 1 1042 15 discriminator 1 view .LVU377
 1444 0056 4AB1     		cbz	r2, .L100
 1445              	.L97:
1043:Src/util.c    ****       beepShort(8);
1044:Src/util.c    ****     } else if (!inIdx && inIdx_prev) {                                  // falling edge
 1446              		.loc 1 1044 12 is_stmt 1 view .LVU378
 1447              		.loc 1 1044 15 is_stmt 0 view .LVU379
 1448 0058 13B9     		cbnz	r3, .L92
 1449              		.loc 1 1044 23 discriminator 1 view .LVU380
 1450 005a 114B     		ldr	r3, .L102+36
 1451 005c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1452 005e 4BB9     		cbnz	r3, .L101
 1453              	.L92:
1045:Src/util.c    ****       beepShort(18);
1046:Src/util.c    ****     }
1047:Src/util.c    **** }
 1454              		.loc 1 1047 1 view .LVU381
 1455 0060 08BD     		pop	{r3, pc}
 1456              	.L95:
1038:Src/util.c    ****     }
 1457              		.loc 1 1038 7 is_stmt 1 view .LVU382
1038:Src/util.c    ****     }
 1458              		.loc 1 1038 19 is_stmt 0 view .LVU383
 1459 0062 104B     		ldr	r3, .L102+40
 1460 0064 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1461 0066 0A4B     		ldr	r3, .L102+20
 1462 0068 1A70     		strb	r2, [r3]
 1463 006a EFE7     		b	.L96
 1464              	.L100:
1043:Src/util.c    ****       beepShort(8);
 1465              		.loc 1 1043 7 is_stmt 1 view .LVU384
 1466 006c 0820     		movs	r0, #8
 1467 006e FFF7FEFF 		bl	beepShort
 1468              	.LVL83:
 1469 0072 F5E7     		b	.L92
 1470              	.L101:
1045:Src/util.c    ****       beepShort(18);
 1471              		.loc 1 1045 7 view .LVU385
 1472 0074 1220     		movs	r0, #18
 1473 0076 FFF7FEFF 		bl	beepShort
 1474              	.LVL84:
 1475              		.loc 1 1047 1 is_stmt 0 view .LVU386
 1476 007a F1E7     		b	.L92
 1477              	.L103:
 1478              		.align	2
 1479              	.L102:
 1480 007c 00000000 		.word	timeoutCntSerial_L
 1481 0080 00000000 		.word	timeoutFlgSerial_L
 1482 0084 00000000 		.word	timeoutFlgSerial
 1483 0088 00000000 		.word	timeoutFlgADC
 1484 008c 00000000 		.word	timeoutFlgGen
 1485 0090 00000000 		.word	ctrlModReq
ARM GAS  /tmp/ccQoOasm.s 			page 48


 1486 0094 00000000 		.word	inIdx
 1487 0098 00000000 		.word	input1
 1488 009c 00000000 		.word	input2
 1489 00a0 00000000 		.word	inIdx_prev
 1490 00a4 00000000 		.word	ctrlModReqRaw
 1491              		.cfi_endproc
 1492              	.LFE84:
 1494              		.section	.text.readCommand,"ax",%progbits
 1495              		.align	1
 1496              		.global	readCommand
 1497              		.syntax unified
 1498              		.thumb
 1499              		.thumb_func
 1501              	readCommand:
 1502              	.LFB85:
1048:Src/util.c    **** 
1049:Src/util.c    ****  /*
1050:Src/util.c    ****  * Function to calculate the command to the motors. This function also manages:
1051:Src/util.c    ****  * - timeout detection
1052:Src/util.c    ****  * - MIN/MAX limitations and deadband
1053:Src/util.c    ****  */
1054:Src/util.c    **** void readCommand(void) {
 1503              		.loc 1 1054 24 is_stmt 1 view -0
 1504              		.cfi_startproc
 1505              		@ args = 0, pretend = 0, frame = 0
 1506              		@ frame_needed = 0, uses_anonymous_args = 0
 1507 0000 70B5     		push	{r4, r5, r6, lr}
 1508              	.LCFI12:
 1509              		.cfi_def_cfa_offset 16
 1510              		.cfi_offset 4, -16
 1511              		.cfi_offset 5, -12
 1512              		.cfi_offset 6, -8
 1513              		.cfi_offset 14, -4
1055:Src/util.c    ****     readInputRaw();
 1514              		.loc 1 1055 5 view .LVU388
 1515 0002 FFF7FEFF 		bl	readInputRaw
 1516              	.LVL85:
1056:Src/util.c    **** 
1057:Src/util.c    ****     #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1058:Src/util.c    ****       calcInputCmd(&input1[inIdx], INPUT_MIN, INPUT_MAX);
 1517              		.loc 1 1058 7 view .LVU389
 1518              		.loc 1 1058 27 is_stmt 0 view .LVU390
 1519 0006 0F4E     		ldr	r6, .L106
 1520 0008 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1521              		.loc 1 1058 7 view .LVU391
 1522 000a 0F4D     		ldr	r5, .L106+4
 1523 000c 0F4C     		ldr	r4, .L106+8
 1524 000e C3EBC303 		rsb	r3, r3, r3, lsl #3
 1525 0012 5800     		lsls	r0, r3, #1
 1526 0014 B5F90020 		ldrsh	r2, [r5]
 1527 0018 B4F90010 		ldrsh	r1, [r4]
 1528 001c 0C4B     		ldr	r3, .L106+12
 1529 001e 1844     		add	r0, r0, r3
 1530 0020 FFF7FEFF 		bl	calcInputCmd
 1531              	.LVL86:
1059:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
1060:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_MIN, INPUT_MAX);
ARM GAS  /tmp/ccQoOasm.s 			page 49


 1532              		.loc 1 1060 9 is_stmt 1 view .LVU392
 1533              		.loc 1 1060 29 is_stmt 0 view .LVU393
 1534 0024 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1535              		.loc 1 1060 9 view .LVU394
 1536 0026 C3EBC303 		rsb	r3, r3, r3, lsl #3
 1537 002a 5800     		lsls	r0, r3, #1
 1538 002c B5F90020 		ldrsh	r2, [r5]
 1539 0030 B4F90010 		ldrsh	r1, [r4]
 1540 0034 074B     		ldr	r3, .L106+16
 1541 0036 1844     		add	r0, r0, r3
 1542 0038 FFF7FEFF 		bl	calcInputCmd
 1543              	.LVL87:
1061:Src/util.c    ****       #else
1062:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_BRK, INPUT_MAX);
1063:Src/util.c    ****       #endif
1064:Src/util.c    ****     #endif
1065:Src/util.c    **** 
1066:Src/util.c    ****     handleTimeout();
 1544              		.loc 1 1066 5 is_stmt 1 view .LVU395
 1545 003c FFF7FEFF 		bl	handleTimeout
 1546              	.LVL88:
1067:Src/util.c    **** 
1068:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1069:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
1070:Src/util.c    ****       brakePressed = (uint8_t)(input1[inIdx].cmd > 50);
1071:Src/util.c    ****     }
1072:Src/util.c    ****     else {
1073:Src/util.c    ****       brakePressed = (uint8_t)(input2[inIdx].cmd < -50);
1074:Src/util.c    ****     }
1075:Src/util.c    ****     #endif
1076:Src/util.c    **** 
1077:Src/util.c    ****     #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
1078:Src/util.c    ****       button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
1079:Src/util.c    ****       button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
1080:Src/util.c    ****     #endif
1081:Src/util.c    **** 
1082:Src/util.c    ****     #if defined(CRUISE_CONTROL_SUPPORT) && (defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEF
1083:Src/util.c    ****         cruiseControl(button1);                                           // Cruise control activat
1084:Src/util.c    ****     #endif
1085:Src/util.c    **** }
 1547              		.loc 1 1085 1 is_stmt 0 view .LVU396
 1548 0040 70BD     		pop	{r4, r5, r6, pc}
 1549              	.L107:
 1550 0042 00BF     		.align	2
 1551              	.L106:
 1552 0044 00000000 		.word	inIdx
 1553 0048 00000000 		.word	INPUT_MAX
 1554 004c 00000000 		.word	INPUT_MIN
 1555 0050 00000000 		.word	input1
 1556 0054 00000000 		.word	input2
 1557              		.cfi_endproc
 1558              	.LFE85:
 1560              		.section	.text.usart3_rx_check,"ax",%progbits
 1561              		.align	1
 1562              		.global	usart3_rx_check
 1563              		.syntax unified
 1564              		.thumb
ARM GAS  /tmp/ccQoOasm.s 			page 50


 1565              		.thumb_func
 1567              	usart3_rx_check:
 1568              	.LFB87:
1086:Src/util.c    **** 
1087:Src/util.c    **** 
1088:Src/util.c    **** /*
1089:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
1090:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1091:Src/util.c    ****  */
1092:Src/util.c    **** void usart2_rx_check(void)
1093:Src/util.c    **** {
1094:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1095:Src/util.c    ****   static uint32_t old_pos;
1096:Src/util.c    ****   uint32_t pos;
1097:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
1098:Src/util.c    ****   #endif
1099:Src/util.c    **** 
1100:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
1101:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1102:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1103:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1104:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
1105:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1106:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy dat
1107:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1108:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_L_len - old_pos], &rx_buffer_L[0], pos);                       
1109:Src/util.c    ****       }
1110:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_L_len - old_pos + pos);        // Process data
1111:Src/util.c    ****     }
1112:Src/util.c    ****   }
1113:Src/util.c    ****   #endif // DEBUG_SERIAL_USART2
1114:Src/util.c    **** 
1115:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
1116:Src/util.c    ****   uint8_t *ptr;	
1117:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1118:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
1119:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
1120:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
1121:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1122:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
1123:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1124:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1125:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1126:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1127:Src/util.c    ****       }
1128:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1129:Src/util.c    ****     }
1130:Src/util.c    ****   }
1131:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
1132:Src/util.c    **** 
1133:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART2
1134:Src/util.c    ****   uint8_t *ptr;	
1135:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1136:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
1137:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
1138:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
1139:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
ARM GAS  /tmp/ccQoOasm.s 			page 51


1140:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
1141:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1142:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1143:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1144:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1145:Src/util.c    ****       }
1146:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1147:Src/util.c    ****     }
1148:Src/util.c    ****   }
1149:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
1150:Src/util.c    **** 
1151:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1152:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1153:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
1154:Src/util.c    ****     old_pos = 0;
1155:Src/util.c    ****   }
1156:Src/util.c    **** 	#endif
1157:Src/util.c    **** }
1158:Src/util.c    **** 
1159:Src/util.c    **** 
1160:Src/util.c    **** /*
1161:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
1162:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1163:Src/util.c    ****  */
1164:Src/util.c    **** void usart3_rx_check(void)
1165:Src/util.c    **** {
 1569              		.loc 1 1165 1 is_stmt 1 view -0
 1570              		.cfi_startproc
 1571              		@ args = 0, pretend = 0, frame = 0
 1572              		@ frame_needed = 0, uses_anonymous_args = 0
 1573              		@ link register save eliminated.
1166:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1167:Src/util.c    ****   static uint32_t old_pos;
1168:Src/util.c    ****   uint32_t pos;  
1169:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
1170:Src/util.c    ****   #endif
1171:Src/util.c    **** 
1172:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
1173:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1174:Src/util.c    **** 
1175:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1176:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1177:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
1178:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1179:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy dat
1180:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1181:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                       
1182:Src/util.c    ****       }
1183:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_R_len - old_pos + pos);        // Process data
1184:Src/util.c    ****     }
1185:Src/util.c    ****   }
1186:Src/util.c    ****   #endif // DEBUG_SERIAL_USART3
1187:Src/util.c    **** 
1188:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
1189:Src/util.c    ****   uint8_t *ptr;
1190:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1191:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
ARM GAS  /tmp/ccQoOasm.s 			page 52


1192:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
1193:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
1194:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1195:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
1196:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1197:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1198:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1199:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1200:Src/util.c    ****       }
1201:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1202:Src/util.c    ****     }
1203:Src/util.c    ****   }
1204:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
1205:Src/util.c    **** 
1206:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART3
1207:Src/util.c    ****   uint8_t *ptr;
1208:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1209:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
1210:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
1211:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
1212:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1213:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
1214:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1215:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1216:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1217:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1218:Src/util.c    ****       }
1219:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1220:Src/util.c    ****     }
1221:Src/util.c    ****   }
1222:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1223:Src/util.c    **** 
1224:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1225:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1226:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
1227:Src/util.c    ****     old_pos = 0;
1228:Src/util.c    ****   }
1229:Src/util.c    ****   #endif
1230:Src/util.c    **** }
 1574              		.loc 1 1230 1 view .LVU398
 1575 0000 7047     		bx	lr
 1576              		.cfi_endproc
 1577              	.LFE87:
 1579              		.section	.text.usart_process_command,"ax",%progbits
 1580              		.align	1
 1581              		.global	usart_process_command
 1582              		.syntax unified
 1583              		.thumb
 1584              		.thumb_func
 1586              	usart_process_command:
 1587              	.LVL89:
 1588              	.LFB88:
1231:Src/util.c    **** 
1232:Src/util.c    **** /*
1233:Src/util.c    ****  * Process Rx debug user command input
1234:Src/util.c    ****  */
1235:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /tmp/ccQoOasm.s 			page 53


1236:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
1237:Src/util.c    **** {
1238:Src/util.c    ****   #ifdef DEBUG_SERIAL_PROTOCOL
1239:Src/util.c    ****     handle_input(userCommand, len);
1240:Src/util.c    ****   #endif
1241:Src/util.c    **** }
1242:Src/util.c    **** 
1243:Src/util.c    **** #endif // SERIAL_DEBUG
1244:Src/util.c    **** 
1245:Src/util.c    **** /*
1246:Src/util.c    ****  * Process command Rx data
1247:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1248:Src/util.c    ****  */
1249:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1250:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1251:Src/util.c    **** {
 1589              		.loc 1 1251 1 view -0
 1590              		.cfi_startproc
 1591              		@ args = 0, pretend = 0, frame = 0
 1592              		@ frame_needed = 0, uses_anonymous_args = 0
 1593              		@ link register save eliminated.
1252:Src/util.c    ****   #ifdef CONTROL_IBUS
1253:Src/util.c    ****     uint16_t ibus_chksum;
1254:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1255:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1256:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1257:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1258:Src/util.c    ****       }
1259:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1260:Src/util.c    ****         *command_out = *command_in;
1261:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1262:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
1263:Src/util.c    ****           timeoutFlgSerial_L = 0;         // Clear timeout flag
1264:Src/util.c    ****           timeoutCntSerial_L = 0;         // Reset timeout counter
1265:Src/util.c    ****           #endif
1266:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1267:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1268:Src/util.c    ****           timeoutFlgSerial_R = 0;         // Clear timeout flag
1269:Src/util.c    ****           timeoutCntSerial_R = 0;         // Reset timeout counter
1270:Src/util.c    ****           #endif
1271:Src/util.c    ****         }
1272:Src/util.c    ****       }
1273:Src/util.c    ****     }
1274:Src/util.c    ****   #else
1275:Src/util.c    ****   uint16_t checksum;
 1594              		.loc 1 1275 3 view .LVU400
1276:Src/util.c    ****   if (command_in->start == SERIAL_START_FRAME) {
 1595              		.loc 1 1276 3 view .LVU401
 1596              		.loc 1 1276 17 is_stmt 0 view .LVU402
 1597 0000 0388     		ldrh	r3, [r0]
 1598              		.loc 1 1276 6 view .LVU403
 1599 0002 4AF6CD3C 		movw	ip, #43981
 1600 0006 6345     		cmp	r3, ip
 1601 0008 05D0     		beq	.L112
 1602              	.LVL90:
 1603              	.L110:
1277:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
ARM GAS  /tmp/ccQoOasm.s 			page 54


1278:Src/util.c    ****     if (command_in->checksum == checksum) {
1279:Src/util.c    ****       *command_out = *command_in;
1280:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1281:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1282:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1283:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
1284:Src/util.c    ****         #endif
1285:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1286:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1287:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1288:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1289:Src/util.c    ****         #endif
1290:Src/util.c    ****       }
 1604              		.loc 1 1290 7 is_stmt 1 view .LVU404
1291:Src/util.c    ****     }
1292:Src/util.c    ****   }
1293:Src/util.c    ****   if (command_in->start == 0xCAFE)
 1605              		.loc 1 1293 3 view .LVU405
 1606              		.loc 1 1293 17 is_stmt 0 view .LVU406
 1607 000a 0288     		ldrh	r2, [r0]
 1608              		.loc 1 1293 6 view .LVU407
 1609 000c 4CF6FE23 		movw	r3, #51966
 1610 0010 9A42     		cmp	r2, r3
 1611 0012 1CD0     		beq	.L113
 1612              	.L109:
1294:Src/util.c    ****   {
1295:Src/util.c    ****     inactivity_timeout_counter = (INACTIVITY_TIMEOUT * 60 * 1000) / (DELAY_IN_MAIN_LOOP + 1);
1296:Src/util.c    ****   }
1297:Src/util.c    ****   #endif
1298:Src/util.c    **** }
 1613              		.loc 1 1298 1 view .LVU408
 1614 0014 7047     		bx	lr
 1615              	.LVL91:
 1616              	.L112:
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1617              		.loc 1 1277 5 is_stmt 1 view .LVU409
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1618              		.loc 1 1277 37 is_stmt 0 view .LVU410
 1619 0016 1BB2     		sxth	r3, r3
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1620              		.loc 1 1277 57 view .LVU411
 1621 0018 B0F902C0 		ldrsh	ip, [r0, #2]
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1622              		.loc 1 1277 45 view .LVU412
 1623 001c 83EA0C03 		eor	r3, r3, ip
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1624              		.loc 1 1277 77 view .LVU413
 1625 0020 B0F904C0 		ldrsh	ip, [r0, #4]
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1626              		.loc 1 1277 65 view .LVU414
 1627 0024 83EA0C03 		eor	r3, r3, ip
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
 1628              		.loc 1 1277 14 view .LVU415
 1629 0028 9BB2     		uxth	r3, r3
 1630              	.LVL92:
1278:Src/util.c    ****       *command_out = *command_in;
 1631              		.loc 1 1278 5 is_stmt 1 view .LVU416
ARM GAS  /tmp/ccQoOasm.s 			page 55


1278:Src/util.c    ****       *command_out = *command_in;
 1632              		.loc 1 1278 19 is_stmt 0 view .LVU417
 1633 002a B0F806C0 		ldrh	ip, [r0, #6]
1278:Src/util.c    ****       *command_out = *command_in;
 1634              		.loc 1 1278 8 view .LVU418
 1635 002e 9C45     		cmp	ip, r3
 1636 0030 EBD1     		bne	.L110
1279:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1637              		.loc 1 1279 7 is_stmt 1 view .LVU419
1279:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1638              		.loc 1 1279 20 is_stmt 0 view .LVU420
 1639 0032 D0F800C0 		ldr	ip, [r0]	@ unaligned
 1640 0036 4368     		ldr	r3, [r0, #4]	@ unaligned
 1641              	.LVL93:
1279:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1642              		.loc 1 1279 20 view .LVU421
 1643 0038 C1F800C0 		str	ip, [r1]	@ unaligned
 1644 003c 4B60     		str	r3, [r1, #4]	@ unaligned
1280:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 1645              		.loc 1 1280 7 is_stmt 1 view .LVU422
1280:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 1646              		.loc 1 1280 10 is_stmt 0 view .LVU423
 1647 003e 022A     		cmp	r2, #2
 1648 0040 E3D1     		bne	.L110
1282:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
 1649              		.loc 1 1282 9 is_stmt 1 view .LVU424
1282:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
 1650              		.loc 1 1282 28 is_stmt 0 view .LVU425
 1651 0042 0023     		movs	r3, #0
 1652 0044 044A     		ldr	r2, .L114
 1653              	.LVL94:
1282:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
 1654              		.loc 1 1282 28 view .LVU426
 1655 0046 1370     		strb	r3, [r2]
1283:Src/util.c    ****         #endif
 1656              		.loc 1 1283 9 is_stmt 1 view .LVU427
1283:Src/util.c    ****         #endif
 1657              		.loc 1 1283 28 is_stmt 0 view .LVU428
 1658 0048 044A     		ldr	r2, .L114+4
 1659 004a 1380     		strh	r3, [r2]	@ movhi
 1660 004c DDE7     		b	.L110
 1661              	.LVL95:
 1662              	.L113:
1295:Src/util.c    ****   }
 1663              		.loc 1 1295 5 is_stmt 1 view .LVU429
1295:Src/util.c    ****   }
 1664              		.loc 1 1295 32 is_stmt 0 view .LVU430
 1665 004e 044B     		ldr	r3, .L114+8
 1666 0050 044A     		ldr	r2, .L114+12
 1667 0052 1A60     		str	r2, [r3]
 1668              		.loc 1 1298 1 view .LVU431
 1669 0054 DEE7     		b	.L109
 1670              	.L115:
 1671 0056 00BF     		.align	2
 1672              	.L114:
 1673 0058 00000000 		.word	timeoutFlgSerial_L
 1674 005c 00000000 		.word	timeoutCntSerial_L
ARM GAS  /tmp/ccQoOasm.s 			page 56


 1675 0060 00000000 		.word	inactivity_timeout_counter
 1676 0064 009F2400 		.word	2400000
 1677              		.cfi_endproc
 1678              	.LFE88:
 1680              		.section	.text.usart2_rx_check,"ax",%progbits
 1681              		.align	1
 1682              		.global	usart2_rx_check
 1683              		.syntax unified
 1684              		.thumb
 1685              		.thumb_func
 1687              	usart2_rx_check:
 1688              	.LFB86:
1093:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 1689              		.loc 1 1093 1 is_stmt 1 view -0
 1690              		.cfi_startproc
 1691              		@ args = 0, pretend = 0, frame = 0
 1692              		@ frame_needed = 0, uses_anonymous_args = 0
 1693 0000 38B5     		push	{r3, r4, r5, lr}
 1694              	.LCFI13:
 1695              		.cfi_def_cfa_offset 16
 1696              		.cfi_offset 3, -16
 1697              		.cfi_offset 4, -12
 1698              		.cfi_offset 5, -8
 1699              		.cfi_offset 14, -4
1095:Src/util.c    ****   uint32_t pos;
 1700              		.loc 1 1095 3 view .LVU433
1096:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
 1701              		.loc 1 1096 3 view .LVU434
1097:Src/util.c    ****   #endif
 1702              		.loc 1 1097 3 view .LVU435
1097:Src/util.c    ****   #endif
 1703              		.loc 1 1097 27 is_stmt 0 view .LVU436
 1704 0002 1F4B     		ldr	r3, .L126
 1705 0004 5B6B     		ldr	r3, [r3, #52]
 1706 0006 1B68     		ldr	r3, [r3]
 1707 0008 5C68     		ldr	r4, [r3, #4]
1097:Src/util.c    ****   #endif
 1708              		.loc 1 1097 7 view .LVU437
 1709 000a C4F14004 		rsb	r4, r4, #64
 1710              	.LVL96:
1116:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 1711              		.loc 1 1116 3 is_stmt 1 view .LVU438
1117:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
 1712              		.loc 1 1117 3 view .LVU439
1117:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
 1713              		.loc 1 1117 11 is_stmt 0 view .LVU440
 1714 000e 1D4B     		ldr	r3, .L126+4
 1715 0010 1B68     		ldr	r3, [r3]
1117:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
 1716              		.loc 1 1117 6 view .LVU441
 1717 0012 A342     		cmp	r3, r4
 1718 0014 08D0     		beq	.L117
1118:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
 1719              		.loc 1 1118 5 is_stmt 1 view .LVU442
 1720              	.LVL97:
1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1721              		.loc 1 1119 5 view .LVU443
ARM GAS  /tmp/ccQoOasm.s 			page 57


1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1722              		.loc 1 1119 8 is_stmt 0 view .LVU444
 1723 0016 02D2     		bcs	.L118
1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1724              		.loc 1 1119 31 discriminator 1 view .LVU445
 1725 0018 E21A     		subs	r2, r4, r3
1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
 1726              		.loc 1 1119 23 discriminator 1 view .LVU446
 1727 001a 082A     		cmp	r2, #8
 1728 001c 09D0     		beq	.L122
 1729              	.L118:
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1730              		.loc 1 1122 12 is_stmt 1 view .LVU447
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1731              		.loc 1 1122 33 is_stmt 0 view .LVU448
 1732 001e C3F14005 		rsb	r5, r3, #64
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1733              		.loc 1 1122 43 view .LVU449
 1734 0022 2A19     		adds	r2, r5, r4
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
 1735              		.loc 1 1122 15 view .LVU450
 1736 0024 082A     		cmp	r2, #8
 1737 0026 13D0     		beq	.L123
 1738              	.LVL98:
 1739              	.L117:
1152:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
 1740              		.loc 1 1152 3 is_stmt 1 view .LVU451
1152:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
 1741              		.loc 1 1152 11 is_stmt 0 view .LVU452
 1742 0028 164B     		ldr	r3, .L126+4
 1743 002a 1C60     		str	r4, [r3]
1153:Src/util.c    ****     old_pos = 0;
 1744              		.loc 1 1153 3 is_stmt 1 view .LVU453
1153:Src/util.c    ****     old_pos = 0;
 1745              		.loc 1 1153 6 is_stmt 0 view .LVU454
 1746 002c 402C     		cmp	r4, #64
 1747 002e 23D0     		beq	.L124
 1748              	.L116:
1157:Src/util.c    **** 
 1749              		.loc 1 1157 1 view .LVU455
 1750 0030 38BD     		pop	{r3, r4, r5, pc}
 1751              	.LVL99:
 1752              	.L122:
1120:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
 1753              		.loc 1 1120 7 is_stmt 1 view .LVU456
1120:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
 1754              		.loc 1 1120 19 is_stmt 0 view .LVU457
 1755 0032 1549     		ldr	r1, .L126+8
 1756 0034 03EB010C 		add	ip, r3, r1
1120:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
 1757              		.loc 1 1120 7 view .LVU458
 1758 0038 144D     		ldr	r5, .L126+12
 1759 003a 2A46     		mov	r2, r5
 1760 003c C858     		ldr	r0, [r1, r3]	@ unaligned
 1761 003e DCF80410 		ldr	r1, [ip, #4]	@ unaligned
 1762 0042 03C2     		stmia	r2!, {r0, r1}
1121:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
ARM GAS  /tmp/ccQoOasm.s 			page 58


 1763              		.loc 1 1121 7 is_stmt 1 view .LVU459
 1764 0044 0222     		movs	r2, #2
 1765 0046 1249     		ldr	r1, .L126+16
 1766 0048 2846     		mov	r0, r5
 1767 004a FFF7FEFF 		bl	usart_process_command
 1768              	.LVL100:
 1769 004e EBE7     		b	.L117
 1770              	.L123:
1123:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 1771              		.loc 1 1123 7 view .LVU460
 1772 0050 2A46     		mov	r2, r5
 1773 0052 0D49     		ldr	r1, .L126+8
 1774 0054 1944     		add	r1, r1, r3
 1775 0056 0D48     		ldr	r0, .L126+12
 1776 0058 FFF7FEFF 		bl	memcpy
 1777              	.LVL101:
1124:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
 1778              		.loc 1 1124 7 view .LVU461
1124:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
 1779              		.loc 1 1124 10 is_stmt 0 view .LVU462
 1780 005c 2CB9     		cbnz	r4, .L125
 1781              	.LVL102:
 1782              	.L119:
1128:Src/util.c    ****     }
 1783              		.loc 1 1128 7 is_stmt 1 view .LVU463
 1784 005e 0222     		movs	r2, #2
 1785 0060 0B49     		ldr	r1, .L126+16
 1786 0062 0A48     		ldr	r0, .L126+12
 1787 0064 FFF7FEFF 		bl	usart_process_command
 1788              	.LVL103:
 1789 0068 DEE7     		b	.L117
 1790              	.LVL104:
 1791              	.L125:
1125:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
 1792              		.loc 1 1125 9 view .LVU464
1126:Src/util.c    ****       }
 1793              		.loc 1 1126 9 view .LVU465
 1794 006a 2246     		mov	r2, r4
 1795 006c 0649     		ldr	r1, .L126+8
 1796 006e 0748     		ldr	r0, .L126+12
 1797 0070 2844     		add	r0, r0, r5
 1798              	.LVL105:
1126:Src/util.c    ****       }
 1799              		.loc 1 1126 9 is_stmt 0 view .LVU466
 1800 0072 FFF7FEFF 		bl	memcpy
 1801              	.LVL106:
1126:Src/util.c    ****       }
 1802              		.loc 1 1126 9 view .LVU467
 1803 0076 F2E7     		b	.L119
 1804              	.LVL107:
 1805              	.L124:
1154:Src/util.c    ****   }
 1806              		.loc 1 1154 5 is_stmt 1 view .LVU468
1154:Src/util.c    ****   }
 1807              		.loc 1 1154 13 is_stmt 0 view .LVU469
 1808 0078 0022     		movs	r2, #0
 1809 007a 1A60     		str	r2, [r3]
ARM GAS  /tmp/ccQoOasm.s 			page 59


1157:Src/util.c    **** 
 1810              		.loc 1 1157 1 view .LVU470
 1811 007c D8E7     		b	.L116
 1812              	.L127:
 1813 007e 00BF     		.align	2
 1814              	.L126:
 1815 0080 00000000 		.word	huart2
 1816 0084 00000000 		.word	old_pos.0
 1817 0088 00000000 		.word	rx_buffer_L
 1818 008c 00000000 		.word	commandL_raw
 1819 0090 00000000 		.word	commandL
 1820              		.cfi_endproc
 1821              	.LFE86:
 1823              		.section	.text.sideboardLeds,"ax",%progbits
 1824              		.align	1
 1825              		.global	sideboardLeds
 1826              		.syntax unified
 1827              		.thumb
 1828              		.thumb_func
 1830              	sideboardLeds:
 1831              	.LVL108:
 1832              	.LFB89:
1299:Src/util.c    **** #endif
1300:Src/util.c    **** 
1301:Src/util.c    **** /*
1302:Src/util.c    ****  * Process Sideboard Rx data
1303:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1304:Src/util.c    ****  */
1305:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1306:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1307:Src/util.c    **** {
1308:Src/util.c    ****   uint16_t checksum;
1309:Src/util.c    ****   if (Sideboard_in->start == SERIAL_START_FRAME) {
1310:Src/util.c    ****     checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->pitch ^ Sideboard_in->dPitch ^ Sidebo
1311:Src/util.c    ****     if (Sideboard_in->checksum == checksum) {
1312:Src/util.c    ****       *Sideboard_out = *Sideboard_in;
1313:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1314:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
1315:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1316:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1317:Src/util.c    ****         #endif
1318:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1319:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1320:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1321:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1322:Src/util.c    ****         #endif
1323:Src/util.c    ****       }
1324:Src/util.c    ****     }
1325:Src/util.c    ****   }
1326:Src/util.c    **** }
1327:Src/util.c    **** #endif
1328:Src/util.c    **** 
1329:Src/util.c    **** 
1330:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1331:Src/util.c    **** 
1332:Src/util.c    **** /*
1333:Src/util.c    ****  * Sideboard LEDs Handling
ARM GAS  /tmp/ccQoOasm.s 			page 60


1334:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1335:Src/util.c    ****  */
1336:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1833              		.loc 1 1336 35 is_stmt 1 view -0
 1834              		.cfi_startproc
 1835              		@ args = 0, pretend = 0, frame = 0
 1836              		@ frame_needed = 0, uses_anonymous_args = 0
 1837              		@ link register save eliminated.
1337:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1338:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1339:Src/util.c    ****     // enable == 1, turn on led
1340:Src/util.c    ****     // enable == 0, blink led
1341:Src/util.c    ****     if (enable) {
1342:Src/util.c    ****       *leds |= LED4_SET;
1343:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
1344:Src/util.c    ****       *leds ^= LED4_SET;
1345:Src/util.c    ****     }
1346:Src/util.c    **** 
1347:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1348:Src/util.c    ****     // backwardDrive == 1, blink led
1349:Src/util.c    ****     // backwardDrive == 0, turn off led
1350:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1351:Src/util.c    ****       *leds ^= LED5_SET;
1352:Src/util.c    ****     }
1353:Src/util.c    **** 
1354:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1355:Src/util.c    ****     // brakePressed == 1, turn on led
1356:Src/util.c    ****     // brakePressed == 0, turn off led
1357:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1358:Src/util.c    ****       if (brakePressed) {
1359:Src/util.c    ****         *leds |= LED5_SET;
1360:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1361:Src/util.c    ****         *leds &= ~LED5_SET;
1362:Src/util.c    ****       }
1363:Src/util.c    ****     #endif
1364:Src/util.c    **** 
1365:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1366:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
1367:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1368:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;
1369:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1370:Src/util.c    ****         *leds ^= LED1_SET;
1371:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1372:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1373:Src/util.c    ****         *leds |= LED1_SET;
1374:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1375:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1376:Src/util.c    ****         *leds ^= LED3_SET;
1377:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1378:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1379:Src/util.c    ****         *leds |= LED3_SET;
1380:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1381:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1382:Src/util.c    ****         *leds ^= LED2_SET;
1383:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1384:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1385:Src/util.c    ****         *leds |= LED2_SET;
ARM GAS  /tmp/ccQoOasm.s 			page 61


1386:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1387:Src/util.c    ****       }
1388:Src/util.c    ****     }
1389:Src/util.c    **** 
1390:Src/util.c    ****     // Error handling
1391:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1392:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1393:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1394:Src/util.c    ****       *leds |= LED1_SET;
1395:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1396:Src/util.c    ****     }
1397:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial) {
1398:Src/util.c    ****       *leds |= LED3_SET;
1399:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1400:Src/util.c    ****     }
1401:Src/util.c    ****   #endif
1402:Src/util.c    **** }
 1838              		.loc 1 1402 1 view .LVU472
 1839 0000 7047     		bx	lr
 1840              		.cfi_endproc
 1841              	.LFE89:
 1843              		.section	.text.sideboardSensors,"ax",%progbits
 1844              		.align	1
 1845              		.global	sideboardSensors
 1846              		.syntax unified
 1847              		.thumb
 1848              		.thumb_func
 1850              	sideboardSensors:
 1851              	.LVL109:
 1852              	.LFB90:
1403:Src/util.c    **** 
1404:Src/util.c    **** /*
1405:Src/util.c    ****  * Sideboard Sensor Handling
1406:Src/util.c    ****  * This function manages the sideboards photo sensors.
1407:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
1408:Src/util.c    ****  */
1409:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1853              		.loc 1 1409 40 view -0
 1854              		.cfi_startproc
 1855              		@ args = 0, pretend = 0, frame = 0
 1856              		@ frame_needed = 0, uses_anonymous_args = 0
 1857              		@ link register save eliminated.
1410:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1411:Src/util.c    ****     static uint8_t sensor1_index;                                 // holds the press index number f
1412:Src/util.c    ****     static uint8_t sensor1_prev,  sensor2_prev;
1413:Src/util.c    ****     uint8_t sensor1_trig = 0, sensor2_trig = 0;
1414:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
1415:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART2;
1416:Src/util.c    ****     uint16_t sideboardSns = Sideboard_L.sensors;
1417:Src/util.c    ****     #else
1418:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART3;
1419:Src/util.c    ****     uint16_t sideboardSns = Sideboard_R.sensors;
1420:Src/util.c    ****     #endif
1421:Src/util.c    **** 
1422:Src/util.c    ****     if (inIdx == sideboardIdx) {                                  // Use Sideboard data
1423:Src/util.c    ****       sensor1_index = 2 + ((sideboardSns & SWB_SET) >> 9);        // SWB on RC transmitter is used 
1424:Src/util.c    ****       if (sensor1_index == 2) {                                   // FOC control Type
ARM GAS  /tmp/ccQoOasm.s 			page 62


1425:Src/util.c    ****         sensor1_index = (sideboardSns & SWC_SET) >> 11;           // SWC on RC transmitter is used 
1426:Src/util.c    ****       }
1427:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1428:Src/util.c    ****       if (inIdx != inIdx_prev) {                                  // Force one update at Input idx 
1429:Src/util.c    ****         sensor1_trig  = 1;
1430:Src/util.c    ****       }
1431:Src/util.c    ****       sensor1_prev  = sensor1_index;
1432:Src/util.c    ****     } else {                                                      // Use Optical switches
1433:Src/util.c    ****       sensor1_trig  = (sensors & SENSOR1_SET) && !sensor1_prev;   // rising edge detection
1434:Src/util.c    ****       sensor1_prev  =  sensors & SENSOR1_SET;
1435:Src/util.c    ****     }
1436:Src/util.c    **** 
1437:Src/util.c    ****     // Control MODE and Control Type Handling
1438:Src/util.c    ****     if (sensor1_trig) {
1439:Src/util.c    ****       switch (sensor1_index) {
1440:Src/util.c    ****         case 0:     // FOC VOLTAGE
1441:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1442:Src/util.c    ****           ctrlModReqRaw         = VLT_MODE;
1443:Src/util.c    ****           break;
1444:Src/util.c    ****         case 1:     // FOC SPEED
1445:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1446:Src/util.c    ****           ctrlModReqRaw         = SPD_MODE;
1447:Src/util.c    ****           break;
1448:Src/util.c    ****         case 2:     // FOC TORQUE
1449:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1450:Src/util.c    ****           ctrlModReqRaw         = TRQ_MODE;
1451:Src/util.c    ****           break;
1452:Src/util.c    ****         case 3:     // SINUSOIDAL
1453:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = SIN_CTRL;
1454:Src/util.c    ****           break;
1455:Src/util.c    ****         case 4:     // COMMUTATION
1456:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = COM_CTRL;
1457:Src/util.c    ****           break;
1458:Src/util.c    ****       }
1459:Src/util.c    ****       if (inIdx == inIdx_prev) { beepShortMany(sensor1_index + 1, 1); }
1460:Src/util.c    ****       if (++sensor1_index > 4) { sensor1_index = 0; }
1461:Src/util.c    ****     }
1462:Src/util.c    **** 
1463:Src/util.c    ****                                                              // Field Weakening Activation/Deactiva
1464:Src/util.c    ****       static uint8_t  sensor2_index = 1;                          // holds the press index number f
1465:Src/util.c    **** 
1466:Src/util.c    ****       // Override in case the Sideboard control is Active
1467:Src/util.c    ****       if (inIdx == sideboardIdx) {                                // Use Sideboard data
1468:Src/util.c    ****         sensor2_index = (sideboardSns & SWD_SET) >> 13;           // SWD on RC transmitter is used 
1469:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1470:Src/util.c    ****         if (inIdx != inIdx_prev) {                                // Force one update at Input idx 
1471:Src/util.c    ****           sensor2_trig  = 1;
1472:Src/util.c    ****         }
1473:Src/util.c    ****         sensor2_prev  = sensor2_index;
1474:Src/util.c    ****       }else{
1475:Src/util.c    ****         sensor2_trig  = (sensors & SENSOR2_SET) && !sensor2_prev;   // rising edge detection
1476:Src/util.c    ****         sensor2_prev  =  sensors & SENSOR2_SET;
1477:Src/util.c    ****       }
1478:Src/util.c    **** 
1479:Src/util.c    ****       #ifdef CRUISE_CONTROL_SUPPORT                                 // Cruise Control Activation/De
1480:Src/util.c    ****         if (sensor2_trig) {
1481:Src/util.c    ****           cruiseControl(sensor2_trig);
ARM GAS  /tmp/ccQoOasm.s 			page 63


1482:Src/util.c    ****         }
1483:Src/util.c    ****       #else
1484:Src/util.c    ****         if (sensor2_trig) {
1485:Src/util.c    ****           switch (sensor2_index) {
1486:Src/util.c    ****             case 0:     // FW Disabled
1487:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 0; 
1488:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 0;
1489:Src/util.c    ****               Input_Lim_Init();
1490:Src/util.c    ****               break;
1491:Src/util.c    ****             case 1:     // FW Enabled
1492:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 1; 
1493:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 1;
1494:Src/util.c    ****               Input_Lim_Init();
1495:Src/util.c    ****               break; 
1496:Src/util.c    ****           }
1497:Src/util.c    ****           if (inIdx == inIdx_prev) { beepShortMany(sensor2_index + 1, 1); }
1498:Src/util.c    ****           if (++sensor2_index > 1) { sensor2_index = 0; }
1499:Src/util.c    ****         }
1500:Src/util.c    ****       #endif  // CRUISE_CONTROL_SUPPORT
1501:Src/util.c    ****   #endif
1502:Src/util.c    **** }
 1858              		.loc 1 1502 1 view .LVU474
 1859 0000 7047     		bx	lr
 1860              		.cfi_endproc
 1861              	.LFE90:
 1863              		.section	.text.saveConfig,"ax",%progbits
 1864              		.align	1
 1865              		.global	saveConfig
 1866              		.syntax unified
 1867              		.thumb
 1868              		.thumb_func
 1870              	saveConfig:
 1871              	.LFB91:
1503:Src/util.c    **** 
1504:Src/util.c    **** 
1505:Src/util.c    **** 
1506:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
1507:Src/util.c    **** 
1508:Src/util.c    ****  /*
1509:Src/util.c    ****  * Save Configuration to Flash
1510:Src/util.c    ****  * This function makes sure data is not lost after power-off
1511:Src/util.c    ****  */
1512:Src/util.c    **** void saveConfig() {
 1872              		.loc 1 1512 19 view -0
 1873              		.cfi_startproc
 1874              		@ args = 0, pretend = 0, frame = 0
 1875              		@ frame_needed = 0, uses_anonymous_args = 0
 1876 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1877              	.LCFI14:
 1878              		.cfi_def_cfa_offset 32
 1879              		.cfi_offset 3, -32
 1880              		.cfi_offset 4, -28
 1881              		.cfi_offset 5, -24
 1882              		.cfi_offset 6, -20
 1883              		.cfi_offset 7, -16
 1884              		.cfi_offset 8, -12
 1885              		.cfi_offset 9, -8
ARM GAS  /tmp/ccQoOasm.s 			page 64


 1886              		.cfi_offset 14, -4
1513:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
1514:Src/util.c    ****     if (saveValue_valid) {
1515:Src/util.c    ****       HAL_FLASH_Unlock();
1516:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
1517:Src/util.c    ****       HAL_FLASH_Lock();
1518:Src/util.c    ****     }
1519:Src/util.c    ****   #endif
1520:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1521:Src/util.c    ****     if (inp_cal_valid || cur_spd_valid) {
 1887              		.loc 1 1521 5 view .LVU476
 1888              		.loc 1 1521 23 is_stmt 0 discriminator 1 view .LVU477
 1889 0004 364B     		ldr	r3, .L135
 1890 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1891 0008 C3B1     		cbz	r3, .L130
1522:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1523:Src/util.c    ****         printf("Saving configuration to EEprom\r\n");
1524:Src/util.c    ****       #endif
1525:Src/util.c    **** 
1526:Src/util.c    ****       HAL_FLASH_Unlock();
 1892              		.loc 1 1526 7 is_stmt 1 view .LVU478
 1893 000a FFF7FEFF 		bl	HAL_FLASH_Unlock
 1894              	.LVL110:
1527:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0] , (uint16_t)FLASH_WRITE_KEY);
 1895              		.loc 1 1527 7 view .LVU479
 1896 000e 354C     		ldr	r4, .L135+4
 1897 0010 41F20201 		movw	r1, #4098
 1898 0014 2088     		ldrh	r0, [r4]
 1899 0016 FFF7FEFF 		bl	EE_WriteVariable
 1900              	.LVL111:
1528:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1] , (uint16_t)rtP_Left.i_max);
 1901              		.loc 1 1528 7 view .LVU480
 1902              		.loc 1 1528 61 is_stmt 0 view .LVU481
 1903 001a 334D     		ldr	r5, .L135+8
 1904 001c B5F9CE10 		ldrsh	r1, [r5, #206]
 1905              		.loc 1 1528 7 view .LVU482
 1906 0020 89B2     		uxth	r1, r1
 1907 0022 6088     		ldrh	r0, [r4, #2]
 1908 0024 FFF7FEFF 		bl	EE_WriteVariable
 1909              	.LVL112:
1529:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2] , (uint16_t)rtP_Left.n_max);
 1910              		.loc 1 1529 7 is_stmt 1 view .LVU483
 1911              		.loc 1 1529 61 is_stmt 0 view .LVU484
 1912 0028 B5F9DA10 		ldrsh	r1, [r5, #218]
 1913              		.loc 1 1529 7 view .LVU485
 1914 002c 89B2     		uxth	r1, r1
 1915 002e A088     		ldrh	r0, [r4, #4]
 1916 0030 FFF7FEFF 		bl	EE_WriteVariable
 1917              	.LVL113:
1530:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 1918              		.loc 1 1530 7 is_stmt 1 view .LVU486
 1919              	.LBB9:
 1920              		.loc 1 1530 12 view .LVU487
 1921              		.loc 1 1530 20 is_stmt 0 view .LVU488
 1922 0034 0025     		movs	r5, #0
 1923              	.LVL114:
 1924              	.L132:
ARM GAS  /tmp/ccQoOasm.s 			page 65


 1925              		.loc 1 1530 26 is_stmt 1 discriminator 1 view .LVU489
 1926 0036 1DB1     		cbz	r5, .L133
 1927              	.LBE9:
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 4+8*i] , (uint16_t)input1[i].min);
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
1534:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
1535:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
1536:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
1537:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
1538:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
1539:Src/util.c    ****       }
1540:Src/util.c    ****       HAL_FLASH_Lock();
 1928              		.loc 1 1540 7 view .LVU490
 1929 0038 FFF7FEFF 		bl	HAL_FLASH_Lock
 1930              	.LVL115:
 1931              	.L130:
1541:Src/util.c    ****     }
1542:Src/util.c    ****   #endif 
1543:Src/util.c    **** }
 1932              		.loc 1 1543 1 is_stmt 0 view .LVU491
 1933 003c BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1934              	.LVL116:
 1935              	.L133:
 1936              	.LBB10:
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1937              		.loc 1 1531 9 is_stmt 1 view .LVU492
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1938              		.loc 1 1531 44 is_stmt 0 view .LVU493
 1939 0040 EC00     		lsls	r4, r5, #3
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1940              		.loc 1 1531 42 view .LVU494
 1941 0042 E01C     		adds	r0, r4, #3
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1942              		.loc 1 1531 69 view .LVU495
 1943 0044 621B     		subs	r2, r4, r5
 1944 0046 5300     		lsls	r3, r2, #1
 1945 0048 284F     		ldr	r7, .L135+12
 1946 004a 1F44     		add	r7, r7, r3
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1947              		.loc 1 1531 9 view .LVU496
 1948 004c 254E     		ldr	r6, .L135+4
 1949 004e 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1950 0050 36F81000 		ldrh	r0, [r6, r0, lsl #1]
 1951 0054 FFF7FEFF 		bl	EE_WriteVariable
 1952              	.LVL117:
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1953              		.loc 1 1532 9 is_stmt 1 view .LVU497
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1954              		.loc 1 1532 42 is_stmt 0 view .LVU498
 1955 0058 231D     		adds	r3, r4, #4
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1956              		.loc 1 1532 69 view .LVU499
 1957 005a B7F90610 		ldrsh	r1, [r7, #6]
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1958              		.loc 1 1532 9 view .LVU500
 1959 005e 89B2     		uxth	r1, r1
ARM GAS  /tmp/ccQoOasm.s 			page 66


 1960 0060 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1961 0064 FFF7FEFF 		bl	EE_WriteVariable
 1962              	.LVL118:
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1963              		.loc 1 1533 9 is_stmt 1 view .LVU501
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1964              		.loc 1 1533 42 is_stmt 0 view .LVU502
 1965 0068 631D     		adds	r3, r4, #5
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1966              		.loc 1 1533 69 view .LVU503
 1967 006a B7F90810 		ldrsh	r1, [r7, #8]
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1968              		.loc 1 1533 9 view .LVU504
 1969 006e 89B2     		uxth	r1, r1
 1970 0070 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1971 0074 FFF7FEFF 		bl	EE_WriteVariable
 1972              	.LVL119:
1534:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1973              		.loc 1 1534 9 is_stmt 1 view .LVU505
1534:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1974              		.loc 1 1534 42 is_stmt 0 view .LVU506
 1975 0078 A31D     		adds	r3, r4, #6
1534:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1976              		.loc 1 1534 69 view .LVU507
 1977 007a B7F90A10 		ldrsh	r1, [r7, #10]
1534:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1978              		.loc 1 1534 9 view .LVU508
 1979 007e 89B2     		uxth	r1, r1
 1980 0080 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1981 0084 FFF7FEFF 		bl	EE_WriteVariable
 1982              	.LVL120:
1535:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1983              		.loc 1 1535 9 is_stmt 1 view .LVU509
1535:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1984              		.loc 1 1535 42 is_stmt 0 view .LVU510
 1985 0088 E21D     		adds	r2, r4, #7
1535:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1986              		.loc 1 1535 69 view .LVU511
 1987 008a DFF86480 		ldr	r8, .L135+16
 1988 008e 631B     		subs	r3, r4, r5
 1989 0090 5F00     		lsls	r7, r3, #1
 1990 0092 4744     		add	r7, r7, r8
1535:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1991              		.loc 1 1535 9 view .LVU512
 1992 0094 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1993 0096 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1994 009a FFF7FEFF 		bl	EE_WriteVariable
 1995              	.LVL121:
1536:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1996              		.loc 1 1536 9 is_stmt 1 view .LVU513
1536:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1997              		.loc 1 1536 42 is_stmt 0 view .LVU514
 1998 009e 05F10109 		add	r9, r5, #1
 1999 00a2 4FEAC903 		lsl	r3, r9, #3
1536:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 2000              		.loc 1 1536 69 view .LVU515
 2001 00a6 B7F90610 		ldrsh	r1, [r7, #6]
ARM GAS  /tmp/ccQoOasm.s 			page 67


1536:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 2002              		.loc 1 1536 9 view .LVU516
 2003 00aa 89B2     		uxth	r1, r1
 2004 00ac 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 2005 00b0 FFF7FEFF 		bl	EE_WriteVariable
 2006              	.LVL122:
1537:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2007              		.loc 1 1537 9 is_stmt 1 view .LVU517
1537:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2008              		.loc 1 1537 42 is_stmt 0 view .LVU518
 2009 00b4 04F10903 		add	r3, r4, #9
1537:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2010              		.loc 1 1537 69 view .LVU519
 2011 00b8 B7F90810 		ldrsh	r1, [r7, #8]
1537:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 2012              		.loc 1 1537 9 view .LVU520
 2013 00bc 89B2     		uxth	r1, r1
 2014 00be 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 2015 00c2 FFF7FEFF 		bl	EE_WriteVariable
 2016              	.LVL123:
1538:Src/util.c    ****       }
 2017              		.loc 1 1538 9 is_stmt 1 view .LVU521
1538:Src/util.c    ****       }
 2018              		.loc 1 1538 42 is_stmt 0 view .LVU522
 2019 00c6 04F10A02 		add	r2, r4, #10
1538:Src/util.c    ****       }
 2020              		.loc 1 1538 69 view .LVU523
 2021 00ca B7F90A10 		ldrsh	r1, [r7, #10]
1538:Src/util.c    ****       }
 2022              		.loc 1 1538 9 view .LVU524
 2023 00ce 89B2     		uxth	r1, r1
 2024 00d0 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 2025 00d4 FFF7FEFF 		bl	EE_WriteVariable
 2026              	.LVL124:
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2027              		.loc 1 1530 39 is_stmt 1 discriminator 3 view .LVU525
 2028 00d8 5FFA89F5 		uxtb	r5, r9
 2029              	.LVL125:
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2030              		.loc 1 1530 39 is_stmt 0 discriminator 3 view .LVU526
 2031 00dc ABE7     		b	.L132
 2032              	.L136:
 2033 00de 00BF     		.align	2
 2034              	.L135:
 2035 00e0 00000000 		.word	cur_spd_valid
 2036 00e4 00000000 		.word	VirtAddVarTab
 2037 00e8 00000000 		.word	rtP_Left
 2038 00ec 00000000 		.word	input1
 2039 00f0 00000000 		.word	input2
 2040              	.LBE10:
 2041              		.cfi_endproc
 2042              	.LFE91:
 2044              		.section	.text.poweroff,"ax",%progbits
 2045              		.align	1
 2046              		.global	poweroff
 2047              		.syntax unified
 2048              		.thumb
ARM GAS  /tmp/ccQoOasm.s 			page 68


 2049              		.thumb_func
 2051              	poweroff:
 2052              	.LFB92:
1544:Src/util.c    **** 
1545:Src/util.c    **** 
1546:Src/util.c    **** void poweroff(void) {
 2053              		.loc 1 1546 21 is_stmt 1 view -0
 2054              		.cfi_startproc
 2055              		@ args = 0, pretend = 0, frame = 0
 2056              		@ frame_needed = 0, uses_anonymous_args = 0
 2057 0000 10B5     		push	{r4, lr}
 2058              	.LCFI15:
 2059              		.cfi_def_cfa_offset 8
 2060              		.cfi_offset 4, -8
 2061              		.cfi_offset 14, -4
1547:Src/util.c    ****   enable = 0;
 2062              		.loc 1 1547 3 view .LVU528
 2063              		.loc 1 1547 10 is_stmt 0 view .LVU529
 2064 0002 0024     		movs	r4, #0
 2065 0004 0B4B     		ldr	r3, .L142
 2066 0006 1C70     		strb	r4, [r3]
1548:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1549:Src/util.c    ****   printf("-- Motors disabled --\r\n");
1550:Src/util.c    ****   #endif
1551:Src/util.c    ****   buzzerCount = 0;  // prevent interraction with beep counter
 2067              		.loc 1 1551 3 is_stmt 1 view .LVU530
 2068              		.loc 1 1551 15 is_stmt 0 view .LVU531
 2069 0008 0B4B     		ldr	r3, .L142+4
 2070 000a 1C70     		strb	r4, [r3]
1552:Src/util.c    ****   buzzerPattern = 0;
 2071              		.loc 1 1552 3 is_stmt 1 view .LVU532
 2072              		.loc 1 1552 17 is_stmt 0 view .LVU533
 2073 000c 0B4B     		ldr	r3, .L142+8
 2074 000e 1C70     		strb	r4, [r3]
1553:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2075              		.loc 1 1553 3 is_stmt 1 view .LVU534
 2076              	.LBB11:
 2077              		.loc 1 1553 8 view .LVU535
 2078              	.LVL126:
 2079              		.loc 1 1553 3 is_stmt 0 view .LVU536
 2080 0010 05E0     		b	.L138
 2081              	.LVL127:
 2082              	.L139:
1554:Src/util.c    ****     buzzerFreq = (uint8_t)i;
 2083              		.loc 1 1554 5 is_stmt 1 view .LVU537
 2084              		.loc 1 1554 16 is_stmt 0 view .LVU538
 2085 0012 0B4B     		ldr	r3, .L142+12
 2086 0014 1C70     		strb	r4, [r3]
1555:Src/util.c    ****     HAL_Delay(100);
 2087              		.loc 1 1555 5 is_stmt 1 view .LVU539
 2088 0016 6420     		movs	r0, #100
 2089 0018 FFF7FEFF 		bl	HAL_Delay
 2090              	.LVL128:
1553:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2091              		.loc 1 1553 27 discriminator 3 view .LVU540
 2092 001c 0134     		adds	r4, r4, #1
 2093              	.LVL129:
ARM GAS  /tmp/ccQoOasm.s 			page 69


 2094              	.L138:
1553:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2095              		.loc 1 1553 21 discriminator 1 view .LVU541
 2096 001e 072C     		cmp	r4, #7
 2097 0020 F7DD     		ble	.L139
 2098              	.LBE11:
1556:Src/util.c    ****   }
1557:Src/util.c    ****   saveConfig();
 2099              		.loc 1 1557 3 view .LVU542
 2100 0022 FFF7FEFF 		bl	saveConfig
 2101              	.LVL130:
1558:Src/util.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 2102              		.loc 1 1558 3 view .LVU543
 2103 0026 0022     		movs	r2, #0
 2104 0028 2021     		movs	r1, #32
 2105 002a 0648     		ldr	r0, .L142+16
 2106 002c FFF7FEFF 		bl	HAL_GPIO_WritePin
 2107              	.LVL131:
 2108              	.L140:
1559:Src/util.c    ****   while(1) {}
 2109              		.loc 1 1559 3 view .LVU544
 2110              		.loc 1 1559 13 view .LVU545
 2111              		.loc 1 1559 8 view .LVU546
 2112 0030 FEE7     		b	.L140
 2113              	.L143:
 2114 0032 00BF     		.align	2
 2115              	.L142:
 2116 0034 00000000 		.word	enable
 2117 0038 00000000 		.word	buzzerCount
 2118 003c 00000000 		.word	buzzerPattern
 2119 0040 00000000 		.word	buzzerFreq
 2120 0044 00080140 		.word	1073809408
 2121              		.cfi_endproc
 2122              	.LFE92:
 2124              		.section	.text.filtLowPass32,"ax",%progbits
 2125              		.align	1
 2126              		.global	filtLowPass32
 2127              		.syntax unified
 2128              		.thumb
 2129              		.thumb_func
 2131              	filtLowPass32:
 2132              	.LVL132:
 2133              	.LFB94:
1560:Src/util.c    **** }
1561:Src/util.c    **** 
1562:Src/util.c    **** 
1563:Src/util.c    **** void poweroffPressCheck(void) {
1564:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1565:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1566:Src/util.c    ****       uint16_t cnt_press = 0;
1567:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1568:Src/util.c    ****         HAL_Delay(10);
1569:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
1570:Src/util.c    ****       }
1571:Src/util.c    **** 
1572:Src/util.c    ****       if (cnt_press > 8) enable = 0;
1573:Src/util.c    **** 
ARM GAS  /tmp/ccQoOasm.s 			page 70


1574:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
1575:Src/util.c    ****         HAL_Delay(1000);
1576:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
1577:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1578:Src/util.c    ****           beepLong(8);
1579:Src/util.c    ****           updateCurSpdLim();
1580:Src/util.c    ****           beepShort(5);
1581:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
1582:Src/util.c    ****           #ifdef AUTO_CALIBRATION_ENA
1583:Src/util.c    ****           beepLong(16); 
1584:Src/util.c    ****           adcCalibLim();
1585:Src/util.c    ****           beepShort(5);
1586:Src/util.c    ****           #endif
1587:Src/util.c    ****         }
1588:Src/util.c    ****       } else if (cnt_press > 8) {                         // Short press: power off (80 ms debounce
1589:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1590:Src/util.c    ****           printf("Powering off, button has been pressed\r\n");
1591:Src/util.c    ****         #endif
1592:Src/util.c    ****       poweroff();
1593:Src/util.c    ****       }
1594:Src/util.c    ****     }
1595:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
1596:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1597:Src/util.c    ****       enable = 0;
1598:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1599:Src/util.c    ****       beepShort(5);
1600:Src/util.c    ****       HAL_Delay(300);
1601:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1602:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1603:Src/util.c    ****         beepLong(5);
1604:Src/util.c    ****         HAL_Delay(350);
1605:Src/util.c    ****         poweroff();
1606:Src/util.c    ****       } else {
1607:Src/util.c    ****         setDistance += 0.25;
1608:Src/util.c    ****         if (setDistance > 2.6) {
1609:Src/util.c    ****           setDistance = 0.5;
1610:Src/util.c    ****         }
1611:Src/util.c    ****         beepShort(setDistance / 0.25);
1612:Src/util.c    ****         saveValue = setDistance * 1000;
1613:Src/util.c    ****         saveValue_valid = 1;
1614:Src/util.c    ****       }
1615:Src/util.c    ****     }
1616:Src/util.c    ****   #else
1617:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1618:Src/util.c    ****       enable = 0;                                             // disable motors
1619:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
1620:Src/util.c    ****       poweroff();                                             // release power-latch
1621:Src/util.c    ****     }
1622:Src/util.c    ****   #endif
1623:Src/util.c    **** }
1624:Src/util.c    **** 
1625:Src/util.c    **** 
1626:Src/util.c    **** 
1627:Src/util.c    **** /* =========================== Filtering Functions =========================== */
1628:Src/util.c    **** 
1629:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1630:Src/util.c    ****   * Max:  32767.99998474121
ARM GAS  /tmp/ccQoOasm.s 			page 71


1631:Src/util.c    ****   * Min: -32768
1632:Src/util.c    ****   * Res:  1.52587890625e-05
1633:Src/util.c    ****   * 
1634:Src/util.c    ****   * Inputs:       u     = int16 or int32
1635:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
1636:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1637:Src/util.c    ****   * 
1638:Src/util.c    ****   * Example: 
1639:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1640:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
1641:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1642:Src/util.c    ****   */
1643:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 2134              		.loc 1 1643 58 view -0
 2135              		.cfi_startproc
 2136              		@ args = 0, pretend = 0, frame = 0
 2137              		@ frame_needed = 0, uses_anonymous_args = 0
 2138              		@ link register save eliminated.
 2139              		.loc 1 1643 58 is_stmt 0 view .LVU548
 2140 0000 10B4     		push	{r4}
 2141              	.LCFI16:
 2142              		.cfi_def_cfa_offset 4
 2143              		.cfi_offset 4, -4
1644:Src/util.c    ****   int64_t tmp;  
 2144              		.loc 1 1644 3 is_stmt 1 view .LVU549
1645:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 2145              		.loc 1 1645 3 view .LVU550
 2146              		.loc 1 1645 32 is_stmt 0 view .LVU551
 2147 0002 1468     		ldr	r4, [r2]
 2148              		.loc 1 1645 35 view .LVU552
 2149 0004 2313     		asrs	r3, r4, #12
 2150              		.loc 1 1645 29 view .LVU553
 2151 0006 C3EB0013 		rsb	r3, r3, r0, lsl #4
 2152              		.loc 1 1645 10 view .LVU554
 2153 000a 4FEAE37C 		asr	ip, r3, #31
 2154              		.loc 1 1645 43 view .LVU555
 2155 000e A1FB0330 		umull	r3, r0, r1, r3
 2156              	.LVL133:
 2157              		.loc 1 1645 43 view .LVU556
 2158 0012 01FB0C01 		mla	r1, r1, ip, r0
 2159              	.LVL134:
 2160              		.loc 1 1645 7 view .LVU557
 2161 0016 1B09     		lsrs	r3, r3, #4
 2162 0018 43EA0173 		orr	r3, r3, r1, lsl #28
 2163 001c 0911     		asrs	r1, r1, #4
 2164              	.LVL135:
1646:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 2165              		.loc 1 1646 3 is_stmt 1 view .LVU558
 2166              		.loc 1 1646 9 is_stmt 0 view .LVU559
 2167 001e B3F1004F 		cmp	r3, #-2147483648
 2168 0022 71F10000 		sbcs	r0, r1, #0
 2169 0026 08DA     		bge	.L147
 2170              		.loc 1 1646 9 discriminator 1 view .LVU560
 2171 0028 1846     		mov	r0, r3
 2172 002a B3F1004F 		cmp	r3, #-2147483648
 2173 002e 71F1FF31 		sbcs	r1, r1, #-1
 2174              	.LVL136:
ARM GAS  /tmp/ccQoOasm.s 			page 72


 2175              		.loc 1 1646 9 discriminator 1 view .LVU561
 2176 0032 04DA     		bge	.L145
 2177 0034 4FF00040 		mov	r0, #-2147483648
 2178 0038 01E0     		b	.L145
 2179              	.LVL137:
 2180              	.L147:
 2181              		.loc 1 1646 9 discriminator 2 view .LVU562
 2182 003a 6FF00040 		mvn	r0, #-2147483648
 2183              	.LVL138:
 2184              	.L145:
1647:Src/util.c    ****   *y = (int32_t)tmp + (*y);
 2185              		.loc 1 1647 3 is_stmt 1 view .LVU563
 2186              		.loc 1 1647 21 is_stmt 0 view .LVU564
 2187 003e 0444     		add	r4, r4, r0
 2188              		.loc 1 1647 6 view .LVU565
 2189 0040 1460     		str	r4, [r2]
1648:Src/util.c    **** }
 2190              		.loc 1 1648 1 view .LVU566
 2191 0042 10BC     		pop	{r4}
 2192              	.LCFI17:
 2193              		.cfi_restore 4
 2194              		.cfi_def_cfa_offset 0
 2195 0044 7047     		bx	lr
 2196              		.cfi_endproc
 2197              	.LFE94:
 2199              		.section	.text.updateCurSpdLim,"ax",%progbits
 2200              		.align	1
 2201              		.global	updateCurSpdLim
 2202              		.syntax unified
 2203              		.thumb
 2204              		.thumb_func
 2206              	updateCurSpdLim:
 2207              	.LFB77:
 613:Src/util.c    ****   calcAvgSpeed();
 2208              		.loc 1 613 28 is_stmt 1 view -0
 2209              		.cfi_startproc
 2210              		@ args = 0, pretend = 0, frame = 8
 2211              		@ frame_needed = 0, uses_anonymous_args = 0
 2212 0000 30B5     		push	{r4, r5, lr}
 2213              	.LCFI18:
 2214              		.cfi_def_cfa_offset 12
 2215              		.cfi_offset 4, -12
 2216              		.cfi_offset 5, -8
 2217              		.cfi_offset 14, -4
 2218 0002 83B0     		sub	sp, sp, #12
 2219              	.LCFI19:
 2220              		.cfi_def_cfa_offset 24
 614:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2221              		.loc 1 614 3 view .LVU568
 2222 0004 FFF7FEFF 		bl	calcAvgSpeed
 2223              	.LVL139:
 615:Src/util.c    ****     return;
 2224              		.loc 1 615 3 view .LVU569
 615:Src/util.c    ****     return;
 2225              		.loc 1 615 19 is_stmt 0 view .LVU570
 2226 0008 504B     		ldr	r3, .L162
 2227 000a B3F90030 		ldrsh	r3, [r3]
ARM GAS  /tmp/ccQoOasm.s 			page 73


 615:Src/util.c    ****     return;
 2228              		.loc 1 615 6 view .LVU571
 2229 000e 052B     		cmp	r3, #5
 2230 0010 00F39480 		bgt	.L149
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2231              		.loc 1 625 3 is_stmt 1 view .LVU572
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2232              		.loc 1 625 40 is_stmt 0 view .LVU573
 2233 0014 4E4B     		ldr	r3, .L162+4
 2234 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2235 0018 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2236 001c 4D4A     		ldr	r2, .L162+8
 2237 001e 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2238              		.loc 1 625 45 view .LVU574
 2239 0022 1204     		lsls	r2, r2, #16
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2240              		.loc 1 625 12 view .LVU575
 2241 0024 0192     		str	r2, [sp, #4]
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2242              		.loc 1 626 3 is_stmt 1 view .LVU576
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2243              		.loc 1 626 40 is_stmt 0 view .LVU577
 2244 0026 4C4A     		ldr	r2, .L162+12
 2245 0028 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2246              		.loc 1 626 45 view .LVU578
 2247 002c 1B04     		lsls	r3, r3, #16
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2248              		.loc 1 626 12 view .LVU579
 2249 002e 0093     		str	r3, [sp]
 627:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 2250              		.loc 1 627 3 is_stmt 1 view .LVU580
 628:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 2251              		.loc 1 628 3 view .LVU581
 629:Src/util.c    ****   cur_spd_valid = 0;
 2252              		.loc 1 629 3 view .LVU582
 2253              	.LVL140:
 630:Src/util.c    **** 
 2254              		.loc 1 630 3 view .LVU583
 630:Src/util.c    **** 
 2255              		.loc 1 630 17 is_stmt 0 view .LVU584
 2256 0030 0024     		movs	r4, #0
 2257 0032 4A4B     		ldr	r3, .L162+16
 2258 0034 1C70     		strb	r4, [r3]
 633:Src/util.c    ****     readInputRaw();
 2259              		.loc 1 633 3 is_stmt 1 view .LVU585
 633:Src/util.c    ****     readInputRaw();
 2260              		.loc 1 633 9 is_stmt 0 view .LVU586
 2261 0036 1CE0     		b	.L152
 2262              	.LVL141:
 2263              	.L154:
 634:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2264              		.loc 1 634 5 is_stmt 1 view .LVU587
 2265 0038 FFF7FEFF 		bl	readInputRaw
 2266              	.LVL142:
 635:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
ARM GAS  /tmp/ccQoOasm.s 			page 74


 2267              		.loc 1 635 5 view .LVU588
 635:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2268              		.loc 1 635 32 is_stmt 0 view .LVU589
 2269 003c 444C     		ldr	r4, .L162+4
 2270 003e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2271 0040 C3EBC303 		rsb	r3, r3, r3, lsl #3
 635:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2272              		.loc 1 635 5 view .LVU590
 2273 0044 01AA     		add	r2, sp, #4
 2274 0046 41F69911 		movw	r1, #6553
 2275 004a 4248     		ldr	r0, .L162+8
 2276 004c 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2277 0050 FFF7FEFF 		bl	filtLowPass32
 2278              	.LVL143:
 636:Src/util.c    ****     HAL_Delay(5);
 2279              		.loc 1 636 5 is_stmt 1 view .LVU591
 636:Src/util.c    ****     HAL_Delay(5);
 2280              		.loc 1 636 32 is_stmt 0 view .LVU592
 2281 0054 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2282 0056 C3EBC303 		rsb	r3, r3, r3, lsl #3
 636:Src/util.c    ****     HAL_Delay(5);
 2283              		.loc 1 636 5 view .LVU593
 2284 005a 6A46     		mov	r2, sp
 2285 005c 41F69911 		movw	r1, #6553
 2286 0060 3D48     		ldr	r0, .L162+12
 2287 0062 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2288 0066 FFF7FEFF 		bl	filtLowPass32
 2289              	.LVL144:
 637:Src/util.c    ****   }
 2290              		.loc 1 637 5 is_stmt 1 view .LVU594
 2291 006a 0520     		movs	r0, #5
 2292 006c FFF7FEFF 		bl	HAL_Delay
 2293              	.LVL145:
 633:Src/util.c    ****     readInputRaw();
 2294              		.loc 1 633 71 is_stmt 0 discriminator 1 view .LVU595
 2295 0070 2C46     		mov	r4, r5
 2296              	.LVL146:
 2297              	.L152:
 633:Src/util.c    ****     readInputRaw();
 2298              		.loc 1 633 53 is_stmt 1 view .LVU596
 633:Src/util.c    ****     readInputRaw();
 2299              		.loc 1 633 11 is_stmt 0 view .LVU597
 2300 0072 0221     		movs	r1, #2
 2301 0074 3A48     		ldr	r0, .L162+20
 2302 0076 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2303              	.LVL147:
 633:Src/util.c    ****     readInputRaw();
 2304              		.loc 1 633 53 discriminator 1 view .LVU598
 2305 007a 20B9     		cbnz	r0, .L153
 633:Src/util.c    ****     readInputRaw();
 2306              		.loc 1 633 71 discriminator 1 view .LVU599
 2307 007c 631C     		adds	r3, r4, #1
 2308 007e 9DB2     		uxth	r5, r3
 2309              	.LVL148:
 633:Src/util.c    ****     readInputRaw();
 2310              		.loc 1 633 53 discriminator 1 view .LVU600
 2311 0080 B4F5FA6F 		cmp	r4, #2000
ARM GAS  /tmp/ccQoOasm.s 			page 75


 2312 0084 D8D3     		bcc	.L154
 2313              	.LVL149:
 2314              	.L153:
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2315              		.loc 1 640 3 is_stmt 1 view .LVU601
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2316              		.loc 1 640 16 is_stmt 0 view .LVU602
 2317 0086 324B     		ldr	r3, .L162+4
 2318 0088 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2319 008a C3EBC302 		rsb	r2, r3, r3, lsl #3
 2320 008e 3149     		ldr	r1, .L162+8
 2321 0090 01EB4201 		add	r1, r1, r2, lsl #1
 2322 0094 B1F90600 		ldrsh	r0, [r1, #6]
 2323 0098 019A     		ldr	r2, [sp, #4]
 2324 009a A2EB0042 		sub	r2, r2, r0, lsl #16
 2325 009e B1F90A10 		ldrsh	r1, [r1, #10]
 2326 00a2 091A     		subs	r1, r1, r0
 2327 00a4 92FBF1F2 		sdiv	r2, r2, r1
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2328              		.loc 1 640 14 view .LVU603
 2329 00a8 B2F5803F 		cmp	r2, #65536
 2330 00ac 48DA     		bge	.L159
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2331              		.loc 1 640 16 discriminator 1 view .LVU604
 2332 00ae 41F69911 		movw	r1, #6553
 2333 00b2 8A42     		cmp	r2, r1
 2334 00b4 B8BF     		it	lt
 2335 00b6 0A46     		movlt	r2, r1
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2336              		.loc 1 640 14 discriminator 1 view .LVU605
 2337 00b8 90B2     		uxth	r0, r2
 2338              	.L155:
 2339              	.LVL150:
 641:Src/util.c    ****       
 2340              		.loc 1 641 3 is_stmt 1 view .LVU606
 641:Src/util.c    ****       
 2341              		.loc 1 641 16 is_stmt 0 view .LVU607
 2342 00ba C3EBC302 		rsb	r2, r3, r3, lsl #3
 2343 00be 2649     		ldr	r1, .L162+12
 2344 00c0 01EB4201 		add	r1, r1, r2, lsl #1
 2345 00c4 B1F90640 		ldrsh	r4, [r1, #6]
 2346 00c8 009A     		ldr	r2, [sp]
 2347 00ca A2EB0442 		sub	r2, r2, r4, lsl #16
 2348 00ce B1F90A10 		ldrsh	r1, [r1, #10]
 2349 00d2 091B     		subs	r1, r1, r4
 2350 00d4 92FBF1F2 		sdiv	r2, r2, r1
 641:Src/util.c    ****       
 2351              		.loc 1 641 14 view .LVU608
 2352 00d8 B2F5803F 		cmp	r2, #65536
 2353 00dc 33DA     		bge	.L160
 641:Src/util.c    ****       
 2354              		.loc 1 641 16 discriminator 1 view .LVU609
 2355 00de 40F6CC41 		movw	r1, #3276
 2356 00e2 8A42     		cmp	r2, r1
 2357 00e4 B8BF     		it	lt
 2358 00e6 0A46     		movlt	r2, r1
 641:Src/util.c    ****       
ARM GAS  /tmp/ccQoOasm.s 			page 76


 2359              		.loc 1 641 14 discriminator 1 view .LVU610
 2360 00e8 92B2     		uxth	r2, r2
 2361              	.L156:
 2362              	.LVL151:
 643:Src/util.c    ****     // Update current limit
 2363              		.loc 1 643 3 is_stmt 1 view .LVU611
 643:Src/util.c    ****     // Update current limit
 2364              		.loc 1 643 20 is_stmt 0 view .LVU612
 2365 00ea C3EBC304 		rsb	r4, r3, r3, lsl #3
 2366 00ee 1949     		ldr	r1, .L162+8
 2367 00f0 01EB4401 		add	r1, r1, r4, lsl #1
 2368 00f4 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 643:Src/util.c    ****     // Update current limit
 2369              		.loc 1 643 6 view .LVU613
 2370 00f6 69B1     		cbz	r1, .L157
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2371              		.loc 1 645 5 is_stmt 1 view .LVU614
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2372              		.loc 1 645 75 is_stmt 0 view .LVU615
 2373 00f8 40F2EE21 		movw	r1, #750
 2374 00fc 00FB01F1 		mul	r1, r0, r1
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2375              		.loc 1 645 41 view .LVU616
 2376 0100 0913     		asrs	r1, r1, #12
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2377              		.loc 1 645 39 view .LVU617
 2378 0102 1848     		ldr	r0, .L162+24
 2379              	.LVL152:
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2380              		.loc 1 645 39 view .LVU618
 2381 0104 A0F8CE10 		strh	r1, [r0, #206]	@ movhi
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2382              		.loc 1 645 20 view .LVU619
 2383 0108 1748     		ldr	r0, .L162+28
 2384 010a A0F8CE10 		strh	r1, [r0, #206]	@ movhi
 646:Src/util.c    ****   }
 2385              		.loc 1 646 5 is_stmt 1 view .LVU620
 646:Src/util.c    ****   }
 2386              		.loc 1 646 21 is_stmt 0 view .LVU621
 2387 010e 1349     		ldr	r1, .L162+16
 2388 0110 0120     		movs	r0, #1
 2389 0112 0870     		strb	r0, [r1]
 2390              	.L157:
 649:Src/util.c    ****     // Update speed limit
 2391              		.loc 1 649 3 is_stmt 1 view .LVU622
 649:Src/util.c    ****     // Update speed limit
 2392              		.loc 1 649 20 is_stmt 0 view .LVU623
 2393 0114 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2394 0118 0F49     		ldr	r1, .L162+12
 2395 011a 01EB4303 		add	r3, r1, r3, lsl #1
 2396 011e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 649:Src/util.c    ****     // Update speed limit
 2397              		.loc 1 649 6 view .LVU624
 2398 0120 63B1     		cbz	r3, .L149
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2399              		.loc 1 651 5 is_stmt 1 view .LVU625
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
ARM GAS  /tmp/ccQoOasm.s 			page 77


 2400              		.loc 1 651 62 is_stmt 0 view .LVU626
 2401 0122 C2EB0212 		rsb	r2, r2, r2, lsl #4
 2402              	.LVL153:
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2403              		.loc 1 651 41 view .LVU627
 2404 0126 9212     		asrs	r2, r2, #10
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2405              		.loc 1 651 39 view .LVU628
 2406 0128 0E4B     		ldr	r3, .L162+24
 2407 012a A3F8DA20 		strh	r2, [r3, #218]	@ movhi
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2408              		.loc 1 651 20 view .LVU629
 2409 012e 0E4B     		ldr	r3, .L162+28
 2410 0130 A3F8DA20 		strh	r2, [r3, #218]	@ movhi
 652:Src/util.c    ****   }
 2411              		.loc 1 652 5 is_stmt 1 view .LVU630
 652:Src/util.c    ****   }
 2412              		.loc 1 652 20 is_stmt 0 view .LVU631
 2413 0134 094A     		ldr	r2, .L162+16
 2414 0136 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 2415 0138 0233     		adds	r3, r3, #2
 2416 013a 1370     		strb	r3, [r2]
 2417              	.LVL154:
 2418              	.L149:
 662:Src/util.c    **** 
 2419              		.loc 1 662 1 view .LVU632
 2420 013c 03B0     		add	sp, sp, #12
 2421              	.LCFI20:
 2422              		.cfi_remember_state
 2423              		.cfi_def_cfa_offset 12
 2424              		@ sp needed
 2425 013e 30BD     		pop	{r4, r5, pc}
 2426              	.L159:
 2427              	.LCFI21:
 2428              		.cfi_restore_state
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2429              		.loc 1 640 14 discriminator 2 view .LVU633
 2430 0140 4FF6FF70 		movw	r0, #65535
 2431 0144 B9E7     		b	.L155
 2432              	.LVL155:
 2433              	.L160:
 641:Src/util.c    ****       
 2434              		.loc 1 641 14 discriminator 2 view .LVU634
 2435 0146 4FF6FF72 		movw	r2, #65535
 2436 014a CEE7     		b	.L156
 2437              	.L163:
 2438              		.align	2
 2439              	.L162:
 2440 014c 00000000 		.word	speedAvgAbs
 2441 0150 00000000 		.word	inIdx
 2442 0154 00000000 		.word	input1
 2443 0158 00000000 		.word	input2
 2444 015c 00000000 		.word	cur_spd_valid
 2445 0160 00080140 		.word	1073809408
 2446 0164 00000000 		.word	rtP_Right
 2447 0168 00000000 		.word	rtP_Left
 2448              		.cfi_endproc
ARM GAS  /tmp/ccQoOasm.s 			page 78


 2449              	.LFE77:
 2451              		.section	.text.poweroffPressCheck,"ax",%progbits
 2452              		.align	1
 2453              		.global	poweroffPressCheck
 2454              		.syntax unified
 2455              		.thumb
 2456              		.thumb_func
 2458              	poweroffPressCheck:
 2459              	.LFB93:
1563:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2460              		.loc 1 1563 31 is_stmt 1 view -0
 2461              		.cfi_startproc
 2462              		@ args = 0, pretend = 0, frame = 0
 2463              		@ frame_needed = 0, uses_anonymous_args = 0
 2464 0000 38B5     		push	{r3, r4, r5, lr}
 2465              	.LCFI22:
 2466              		.cfi_def_cfa_offset 16
 2467              		.cfi_offset 3, -16
 2468              		.cfi_offset 4, -12
 2469              		.cfi_offset 5, -8
 2470              		.cfi_offset 14, -4
1565:Src/util.c    ****       uint16_t cnt_press = 0;
 2471              		.loc 1 1565 5 view .LVU636
1565:Src/util.c    ****       uint16_t cnt_press = 0;
 2472              		.loc 1 1565 8 is_stmt 0 view .LVU637
 2473 0002 0221     		movs	r1, #2
 2474 0004 2048     		ldr	r0, .L176
 2475 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2476              	.LVL156:
1565:Src/util.c    ****       uint16_t cnt_press = 0;
 2477              		.loc 1 1565 7 discriminator 1 view .LVU638
 2478 000a 90B9     		cbnz	r0, .L172
 2479              	.L164:
1623:Src/util.c    **** 
 2480              		.loc 1 1623 1 view .LVU639
 2481 000c 38BD     		pop	{r3, r4, r5, pc}
 2482              	.LVL157:
 2483              	.L167:
1563:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2484              		.loc 1 1563 31 view .LVU640
 2485 000e 2546     		mov	r5, r4
 2486              	.LVL158:
 2487              	.L165:
 2488              	.LBB12:
1567:Src/util.c    ****         HAL_Delay(10);
 2489              		.loc 1 1567 13 is_stmt 1 view .LVU641
 2490 0010 0221     		movs	r1, #2
 2491 0012 1D48     		ldr	r0, .L176
 2492 0014 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2493              	.LVL159:
1567:Src/util.c    ****         HAL_Delay(10);
 2494              		.loc 1 1567 13 is_stmt 0 discriminator 1 view .LVU642
 2495 0018 68B1     		cbz	r0, .L174
1568:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
 2496              		.loc 1 1568 9 is_stmt 1 view .LVU643
 2497 001a 0A20     		movs	r0, #10
 2498 001c FFF7FEFF 		bl	HAL_Delay
ARM GAS  /tmp/ccQoOasm.s 			page 79


 2499              	.LVL160:
1569:Src/util.c    ****       }
 2500              		.loc 1 1569 9 view .LVU644
1569:Src/util.c    ****       }
 2501              		.loc 1 1569 22 is_stmt 0 view .LVU645
 2502 0020 6C1C     		adds	r4, r5, #1
 2503 0022 A4B2     		uxth	r4, r4
 2504              	.LVL161:
1569:Src/util.c    ****       }
 2505              		.loc 1 1569 12 view .LVU646
 2506 0024 B5F5FA7F 		cmp	r5, #500
 2507 0028 F1D1     		bne	.L167
1569:Src/util.c    ****       }
 2508              		.loc 1 1569 39 is_stmt 1 discriminator 1 view .LVU647
 2509 002a 0520     		movs	r0, #5
 2510 002c FFF7FEFF 		bl	beepShort
 2511              	.LVL162:
 2512 0030 EDE7     		b	.L167
 2513              	.LVL163:
 2514              	.L172:
1566:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 2515              		.loc 1 1566 16 is_stmt 0 view .LVU648
 2516 0032 0025     		movs	r5, #0
 2517 0034 ECE7     		b	.L165
 2518              	.LVL164:
 2519              	.L174:
1572:Src/util.c    **** 
 2520              		.loc 1 1572 7 is_stmt 1 view .LVU649
1572:Src/util.c    **** 
 2521              		.loc 1 1572 10 is_stmt 0 view .LVU650
 2522 0036 082D     		cmp	r5, #8
 2523 0038 05D9     		bls	.L169
1572:Src/util.c    **** 
 2524              		.loc 1 1572 26 is_stmt 1 discriminator 1 view .LVU651
1572:Src/util.c    **** 
 2525              		.loc 1 1572 33 is_stmt 0 discriminator 1 view .LVU652
 2526 003a 144B     		ldr	r3, .L176+4
 2527 003c 0022     		movs	r2, #0
 2528 003e 1A70     		strb	r2, [r3]
1574:Src/util.c    ****         HAL_Delay(1000);
 2529              		.loc 1 1574 7 is_stmt 1 view .LVU653
1574:Src/util.c    ****         HAL_Delay(1000);
 2530              		.loc 1 1574 10 is_stmt 0 view .LVU654
 2531 0040 B5F5FA7F 		cmp	r5, #500
 2532 0044 03D2     		bcs	.L175
 2533              	.L169:
1588:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2534              		.loc 1 1588 14 is_stmt 1 view .LVU655
1588:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2535              		.loc 1 1588 17 is_stmt 0 view .LVU656
 2536 0046 082D     		cmp	r5, #8
 2537 0048 E0D9     		bls	.L164
1592:Src/util.c    ****       }
 2538              		.loc 1 1592 7 is_stmt 1 view .LVU657
 2539 004a FFF7FEFF 		bl	poweroff
 2540              	.LVL165:
 2541              	.L175:
ARM GAS  /tmp/ccQoOasm.s 			page 80


1575:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 2542              		.loc 1 1575 9 view .LVU658
 2543 004e 4FF47A70 		mov	r0, #1000
 2544 0052 FFF7FEFF 		bl	HAL_Delay
 2545              	.LVL166:
1576:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2546              		.loc 1 1576 9 view .LVU659
1576:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2547              		.loc 1 1576 13 is_stmt 0 view .LVU660
 2548 0056 0221     		movs	r1, #2
 2549 0058 0B48     		ldr	r0, .L176
 2550 005a FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2551              	.LVL167:
1576:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2552              		.loc 1 1576 12 discriminator 1 view .LVU661
 2553 005e 18B9     		cbnz	r0, .L170
 2554 0060 D4E7     		b	.L164
 2555              	.L171:
1577:Src/util.c    ****           beepLong(8);
 2556              		.loc 1 1577 62 is_stmt 1 discriminator 2 view .LVU662
 2557 0062 0A20     		movs	r0, #10
 2558 0064 FFF7FEFF 		bl	HAL_Delay
 2559              	.LVL168:
 2560              	.L170:
1577:Src/util.c    ****           beepLong(8);
 2561              		.loc 1 1577 17 discriminator 1 view .LVU663
 2562 0068 0221     		movs	r1, #2
 2563 006a 0748     		ldr	r0, .L176
 2564 006c FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2565              	.LVL169:
 2566 0070 0028     		cmp	r0, #0
 2567 0072 F6D1     		bne	.L171
1578:Src/util.c    ****           updateCurSpdLim();
 2568              		.loc 1 1578 11 view .LVU664
 2569 0074 0820     		movs	r0, #8
 2570 0076 FFF7FEFF 		bl	beepLong
 2571              	.LVL170:
1579:Src/util.c    ****           beepShort(5);
 2572              		.loc 1 1579 11 view .LVU665
 2573 007a FFF7FEFF 		bl	updateCurSpdLim
 2574              	.LVL171:
1580:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 2575              		.loc 1 1580 11 view .LVU666
 2576 007e 0520     		movs	r0, #5
 2577 0080 FFF7FEFF 		bl	beepShort
 2578              	.LVL172:
 2579 0084 C2E7     		b	.L164
 2580              	.L177:
 2581 0086 00BF     		.align	2
 2582              	.L176:
 2583 0088 00080140 		.word	1073809408
 2584 008c 00000000 		.word	enable
 2585              	.LBE12:
 2586              		.cfi_endproc
 2587              	.LFE93:
 2589              		.section	.text.rateLimiter16,"ax",%progbits
 2590              		.align	1
ARM GAS  /tmp/ccQoOasm.s 			page 81


 2591              		.global	rateLimiter16
 2592              		.syntax unified
 2593              		.thumb
 2594              		.thumb_func
 2596              	rateLimiter16:
 2597              	.LVL173:
 2598              	.LFB95:
1649:Src/util.c    ****   // Old filter
1650:Src/util.c    ****   // Inputs:       u     = int16
1651:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
1652:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1653:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1654:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1655:Src/util.c    ****   //   int32_t tmp;  
1656:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1657:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1658:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1659:Src/util.c    ****   // }
1660:Src/util.c    **** 
1661:Src/util.c    **** 
1662:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1663:Src/util.c    ****   * Inputs:       u     = int16
1664:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1665:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1666:Src/util.c    ****   */
1667:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 2599              		.loc 1 1667 57 view -0
 2600              		.cfi_startproc
 2601              		@ args = 0, pretend = 0, frame = 0
 2602              		@ frame_needed = 0, uses_anonymous_args = 0
 2603              		@ link register save eliminated.
1668:Src/util.c    ****   int16_t q0;
 2604              		.loc 1 1668 3 view .LVU668
1669:Src/util.c    ****   int16_t q1;
 2605              		.loc 1 1669 3 view .LVU669
1670:Src/util.c    **** 
1671:Src/util.c    ****   q0 = (u << 4)  - *y;
 2606              		.loc 1 1671 3 view .LVU670
 2607              		.loc 1 1671 11 is_stmt 0 view .LVU671
 2608 0000 0301     		lsls	r3, r0, #4
 2609 0002 9BB2     		uxth	r3, r3
 2610              		.loc 1 1671 20 view .LVU672
 2611 0004 1088     		ldrh	r0, [r2]
 2612              	.LVL174:
 2613              		.loc 1 1671 18 view .LVU673
 2614 0006 1B1A     		subs	r3, r3, r0
 2615              		.loc 1 1671 6 view .LVU674
 2616 0008 1BB2     		sxth	r3, r3
 2617              	.LVL175:
1672:Src/util.c    **** 
1673:Src/util.c    ****   if (q0 > rate) {
 2618              		.loc 1 1673 3 is_stmt 1 view .LVU675
 2619              		.loc 1 1673 6 is_stmt 0 view .LVU676
 2620 000a 8B42     		cmp	r3, r1
 2621 000c 04DC     		bgt	.L179
1674:Src/util.c    ****     q0 = rate;
1675:Src/util.c    ****   } else {
ARM GAS  /tmp/ccQoOasm.s 			page 82


1676:Src/util.c    ****     q1 = -rate;
 2622              		.loc 1 1676 5 is_stmt 1 view .LVU677
 2623              		.loc 1 1676 8 is_stmt 0 view .LVU678
 2624 000e 4942     		rsbs	r1, r1, #0
 2625              	.LVL176:
 2626              		.loc 1 1676 8 view .LVU679
 2627 0010 09B2     		sxth	r1, r1
 2628              	.LVL177:
1677:Src/util.c    ****     if (q0 < q1) {
 2629              		.loc 1 1677 5 is_stmt 1 view .LVU680
 2630              		.loc 1 1677 8 is_stmt 0 view .LVU681
 2631 0012 8B42     		cmp	r3, r1
 2632 0014 00DB     		blt	.L179
1671:Src/util.c    **** 
 2633              		.loc 1 1671 6 view .LVU682
 2634 0016 1946     		mov	r1, r3
 2635              	.LVL178:
 2636              	.L179:
1678:Src/util.c    ****       q0 = q1;
1679:Src/util.c    ****     }
1680:Src/util.c    ****   }
1681:Src/util.c    **** 
1682:Src/util.c    ****   *y = q0 + *y;
 2637              		.loc 1 1682 3 is_stmt 1 view .LVU683
 2638              		.loc 1 1682 11 is_stmt 0 view .LVU684
 2639 0018 0844     		add	r0, r0, r1
 2640              		.loc 1 1682 6 view .LVU685
 2641 001a 1080     		strh	r0, [r2]	@ movhi
1683:Src/util.c    **** }
 2642              		.loc 1 1683 1 view .LVU686
 2643 001c 7047     		bx	lr
 2644              		.cfi_endproc
 2645              	.LFE95:
 2647              		.section	.text.mixerFcn,"ax",%progbits
 2648              		.align	1
 2649              		.global	mixerFcn
 2650              		.syntax unified
 2651              		.thumb
 2652              		.thumb_func
 2654              	mixerFcn:
 2655              	.LVL179:
 2656              	.LFB96:
1684:Src/util.c    **** 
1685:Src/util.c    **** 
1686:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
1687:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1688:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1689:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1690:Src/util.c    ****   */
1691:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 2657              		.loc 1 1691 95 is_stmt 1 view -0
 2658              		.cfi_startproc
 2659              		@ args = 0, pretend = 0, frame = 0
 2660              		@ frame_needed = 0, uses_anonymous_args = 0
 2661              		.loc 1 1691 95 is_stmt 0 view .LVU688
 2662 0000 10B5     		push	{r4, lr}
 2663              	.LCFI23:
ARM GAS  /tmp/ccQoOasm.s 			page 83


 2664              		.cfi_def_cfa_offset 8
 2665              		.cfi_offset 4, -8
 2666              		.cfi_offset 14, -4
1692:Src/util.c    ****     int16_t prodSpeed;
 2667              		.loc 1 1692 5 is_stmt 1 view .LVU689
1693:Src/util.c    ****     int16_t prodSteer;
 2668              		.loc 1 1693 5 view .LVU690
1694:Src/util.c    ****     int32_t tmp;
 2669              		.loc 1 1694 5 view .LVU691
1695:Src/util.c    **** 
1696:Src/util.c    ****     prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
 2670              		.loc 1 1696 5 view .LVU692
 2671              	.LVL180:
1697:Src/util.c    ****     prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 2672              		.loc 1 1697 5 view .LVU693
 2673              		.loc 1 1697 17 is_stmt 0 view .LVU694
 2674 0002 4FEA610E 		asr	lr, r1, #1
 2675              	.LVL181:
1698:Src/util.c    **** 
1699:Src/util.c    ****     tmp         = prodSpeed - prodSteer;  
 2676              		.loc 1 1699 5 is_stmt 1 view .LVU695
 2677              		.loc 1 1699 17 is_stmt 0 view .LVU696
 2678 0006 A0EB6101 		sub	r1, r0, r1, asr #1
 2679              	.LVL182:
1700:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2680              		.loc 1 1700 5 is_stmt 1 view .LVU697
 2681              		.loc 1 1700 19 is_stmt 0 view .LVU698
 2682 000a B1F5004F 		cmp	r1, #32768
 2683 000e 26DA     		bge	.L185
 2684              		.loc 1 1700 19 discriminator 1 view .LVU699
 2685 0010 174C     		ldr	r4, .L189
 2686 0012 A142     		cmp	r1, r4
 2687 0014 B8BF     		it	lt
 2688 0016 2146     		movlt	r1, r4
 2689              	.LVL183:
 2690              	.L181:
1701:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2691              		.loc 1 1701 5 is_stmt 1 view .LVU700
 2692              		.loc 1 1701 19 is_stmt 0 view .LVU701
 2693 0018 0911     		asrs	r1, r1, #4
 2694              	.LVL184:
 2695              		.loc 1 1701 17 view .LVU702
 2696 001a 1180     		strh	r1, [r2]	@ movhi
1702:Src/util.c    ****     *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 2697              		.loc 1 1702 5 is_stmt 1 view .LVU703
 2698              		.loc 1 1702 19 is_stmt 0 view .LVU704
 2699 001c 154C     		ldr	r4, .L189+4
 2700 001e B4F900C0 		ldrsh	ip, [r4]
 2701              		.loc 1 1702 17 view .LVU705
 2702 0022 6145     		cmp	r1, ip
 2703 0024 1EDC     		bgt	.L186
 2704              		.loc 1 1702 19 discriminator 1 view .LVU706
 2705 0026 144C     		ldr	r4, .L189+8
 2706 0028 B4F90040 		ldrsh	r4, [r4]
 2707              		.loc 1 1702 17 discriminator 1 view .LVU707
 2708 002c A142     		cmp	r1, r4
 2709 002e B8BF     		it	lt
ARM GAS  /tmp/ccQoOasm.s 			page 84


 2710 0030 2146     		movlt	r1, r4
 2711              	.L182:
 2712              		.loc 1 1702 17 discriminator 4 view .LVU708
 2713 0032 1180     		strh	r1, [r2]	@ movhi
1703:Src/util.c    **** 
1704:Src/util.c    ****     tmp         = prodSpeed + prodSteer;
 2714              		.loc 1 1704 5 is_stmt 1 view .LVU709
 2715              		.loc 1 1704 17 is_stmt 0 view .LVU710
 2716 0034 7044     		add	r0, r0, lr
 2717              	.LVL185:
1705:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2718              		.loc 1 1705 5 is_stmt 1 view .LVU711
 2719              		.loc 1 1705 19 is_stmt 0 view .LVU712
 2720 0036 B0F5004F 		cmp	r0, #32768
 2721 003a 15DA     		bge	.L187
 2722              		.loc 1 1705 19 discriminator 1 view .LVU713
 2723 003c 0C4A     		ldr	r2, .L189
 2724              	.LVL186:
 2725              		.loc 1 1705 19 discriminator 1 view .LVU714
 2726 003e 9042     		cmp	r0, r2
 2727 0040 B8BF     		it	lt
 2728 0042 1046     		movlt	r0, r2
 2729              	.LVL187:
 2730              	.L183:
1706:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2731              		.loc 1 1706 5 is_stmt 1 view .LVU715
 2732              		.loc 1 1706 19 is_stmt 0 view .LVU716
 2733 0044 0211     		asrs	r2, r0, #4
 2734              		.loc 1 1706 17 view .LVU717
 2735 0046 1A80     		strh	r2, [r3]	@ movhi
1707:Src/util.c    ****     *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 2736              		.loc 1 1707 5 is_stmt 1 view .LVU718
 2737              		.loc 1 1707 17 is_stmt 0 view .LVU719
 2738 0048 9445     		cmp	ip, r2
 2739 004a 05DB     		blt	.L184
 2740              		.loc 1 1707 19 discriminator 1 view .LVU720
 2741 004c 0A49     		ldr	r1, .L189+8
 2742 004e B1F900C0 		ldrsh	ip, [r1]
 2743              		.loc 1 1707 17 discriminator 1 view .LVU721
 2744 0052 9445     		cmp	ip, r2
 2745 0054 B8BF     		it	lt
 2746 0056 9446     		movlt	ip, r2
 2747              	.L184:
 2748              		.loc 1 1707 17 discriminator 4 view .LVU722
 2749 0058 A3F800C0 		strh	ip, [r3]	@ movhi
1708:Src/util.c    **** }
 2750              		.loc 1 1708 1 view .LVU723
 2751 005c 10BD     		pop	{r4, pc}
 2752              	.LVL188:
 2753              	.L185:
1700:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2754              		.loc 1 1700 19 discriminator 2 view .LVU724
 2755 005e 47F6FF71 		movw	r1, #32767
 2756              	.LVL189:
1700:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2757              		.loc 1 1700 19 discriminator 2 view .LVU725
 2758 0062 D9E7     		b	.L181
ARM GAS  /tmp/ccQoOasm.s 			page 85


 2759              	.LVL190:
 2760              	.L186:
1702:Src/util.c    **** 
 2761              		.loc 1 1702 17 discriminator 2 view .LVU726
 2762 0064 6146     		mov	r1, ip
 2763 0066 E4E7     		b	.L182
 2764              	.LVL191:
 2765              	.L187:
1705:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2766              		.loc 1 1705 19 discriminator 2 view .LVU727
 2767 0068 47F6FF70 		movw	r0, #32767
 2768              	.LVL192:
1705:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2769              		.loc 1 1705 19 discriminator 2 view .LVU728
 2770 006c EAE7     		b	.L183
 2771              	.L190:
 2772 006e 00BF     		.align	2
 2773              	.L189:
 2774 0070 0080FFFF 		.word	-32768
 2775 0074 00000000 		.word	INPUT_MAX
 2776 0078 00000000 		.word	INPUT_MIN
 2777              		.cfi_endproc
 2778              	.LFE96:
 2780              		.section	.text.multipleTapDet,"ax",%progbits
 2781              		.align	1
 2782              		.global	multipleTapDet
 2783              		.syntax unified
 2784              		.thumb
 2785              		.thumb_func
 2787              	multipleTapDet:
 2788              	.LVL193:
 2789              	.LFB97:
1709:Src/util.c    **** 
1710:Src/util.c    **** 
1711:Src/util.c    **** 
1712:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1713:Src/util.c    **** 
1714:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1715:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1716:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1717:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1718:Src/util.c    ****   */
1719:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 2790              		.loc 1 1719 66 is_stmt 1 view -0
 2791              		.cfi_startproc
 2792              		@ args = 0, pretend = 0, frame = 0
 2793              		@ frame_needed = 0, uses_anonymous_args = 0
 2794              		@ link register save eliminated.
 2795              		.loc 1 1719 66 is_stmt 0 view .LVU730
 2796 0000 30B4     		push	{r4, r5}
 2797              	.LCFI24:
 2798              		.cfi_def_cfa_offset 8
 2799              		.cfi_offset 4, -8
 2800              		.cfi_offset 5, -4
1720:Src/util.c    ****   uint8_t 	b_timeout;
 2801              		.loc 1 1720 3 is_stmt 1 view .LVU731
1721:Src/util.c    ****   uint8_t 	b_hyst;
ARM GAS  /tmp/ccQoOasm.s 			page 86


 2802              		.loc 1 1721 3 view .LVU732
1722:Src/util.c    ****   uint8_t 	b_pulse;
 2803              		.loc 1 1722 3 view .LVU733
1723:Src/util.c    ****   uint8_t 	z_pulseCnt;
 2804              		.loc 1 1723 3 view .LVU734
1724:Src/util.c    ****   uint8_t   z_pulseCntRst;
 2805              		.loc 1 1724 3 view .LVU735
1725:Src/util.c    ****   uint32_t 	t_time; 
 2806              		.loc 1 1725 3 view .LVU736
1726:Src/util.c    **** 
1727:Src/util.c    ****   // Detect hysteresis
1728:Src/util.c    ****   if (x->b_hysteresis) {
 2807              		.loc 1 1728 3 view .LVU737
 2808              		.loc 1 1728 8 is_stmt 0 view .LVU738
 2809 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 2810              		.loc 1 1728 6 view .LVU739
 2811 0004 E4B1     		cbz	r4, .L192
1729:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 2812              		.loc 1 1729 5 is_stmt 1 view .LVU740
 2813              		.loc 1 1729 17 is_stmt 0 view .LVU741
 2814 0006 C828     		cmp	r0, #200
 2815 0008 D4BF     		ite	le
 2816 000a 0020     		movle	r0, #0
 2817              	.LVL194:
 2818              		.loc 1 1729 17 view .LVU742
 2819 000c 0120     		movgt	r0, #1
 2820              	.LVL195:
 2821              	.L193:
1730:Src/util.c    ****   } else {
1731:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
1732:Src/util.c    ****   }
1733:Src/util.c    **** 
1734:Src/util.c    ****   // Detect pulse
1735:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 2822              		.loc 1 1735 3 is_stmt 1 view .LVU743
 2823              		.loc 1 1735 21 is_stmt 0 view .LVU744
 2824 000e 231A     		subs	r3, r4, r0
 2825 0010 18BF     		it	ne
 2826 0012 0123     		movne	r3, #1
 2827              	.LVL196:
1736:Src/util.c    **** 
1737:Src/util.c    ****   // Save time when first pulse is detected
1738:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 2828              		.loc 1 1738 3 is_stmt 1 view .LVU745
 2829              		.loc 1 1738 6 is_stmt 0 view .LVU746
 2830 0014 18B1     		cbz	r0, .L194
 2831              		.loc 1 1738 14 discriminator 1 view .LVU747
 2832 0016 8442     		cmp	r4, r0
 2833 0018 01D0     		beq	.L194
 2834              		.loc 1 1738 30 discriminator 2 view .LVU748
 2835 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 2836              		.loc 1 1738 25 discriminator 2 view .LVU749
 2837 001c B4B1     		cbz	r4, .L199
 2838              	.L194:
1739:Src/util.c    ****     t_time = timeNow;
1740:Src/util.c    ****   } else {
1741:Src/util.c    ****     t_time = x->t_timePrev;
ARM GAS  /tmp/ccQoOasm.s 			page 87


 2839              		.loc 1 1741 5 is_stmt 1 view .LVU750
 2840              		.loc 1 1741 12 is_stmt 0 view .LVU751
 2841 001e 1468     		ldr	r4, [r2]
 2842              	.LVL197:
 2843              	.L195:
1742:Src/util.c    ****   }
1743:Src/util.c    **** 
1744:Src/util.c    ****   // Create timeout boolean
1745:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 2844              		.loc 1 1745 3 is_stmt 1 view .LVU752
 2845              		.loc 1 1745 24 is_stmt 0 view .LVU753
 2846 0020 091B     		subs	r1, r1, r4
 2847              	.LVL198:
1746:Src/util.c    **** 
1747:Src/util.c    ****   // Create pulse counter
1748:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 2848              		.loc 1 1748 3 is_stmt 1 view .LVU754
 2849              		.loc 1 1748 6 is_stmt 0 view .LVU755
 2850 0022 10B9     		cbnz	r0, .L196
 2851              		.loc 1 1748 22 discriminator 1 view .LVU756
 2852 0024 1579     		ldrb	r5, [r2, #4]	@ zero_extendqisi2
 2853              		.loc 1 1748 17 discriminator 1 view .LVU757
 2854 0026 05B9     		cbnz	r5, .L196
1749:Src/util.c    ****     z_pulseCnt = 0U;
 2855              		.loc 1 1749 16 view .LVU758
 2856 0028 2B46     		mov	r3, r5
 2857              	.LVL199:
 2858              	.L196:
1750:Src/util.c    ****   } else {
1751:Src/util.c    ****     z_pulseCnt = b_pulse;
1752:Src/util.c    ****   }
1753:Src/util.c    **** 
1754:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1755:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 2859              		.loc 1 1755 3 is_stmt 1 view .LVU759
 2860              		.loc 1 1755 9 is_stmt 0 view .LVU760
 2861 002a 92F804C0 		ldrb	ip, [r2, #4]	@ zero_extendqisi2
 2862              		.loc 1 1755 6 view .LVU761
 2863 002e BCF1030F 		cmp	ip, #3
 2864 0032 0DD8     		bhi	.L201
 2865              		.loc 1 1755 46 discriminator 1 view .LVU762
 2866 0034 B1F5FA6F 		cmp	r1, #2000
 2867 0038 0CD9     		bls	.L197
1756:Src/util.c    ****     z_pulseCntRst = 0U;
 2868              		.loc 1 1756 19 view .LVU763
 2869 003a 4FF0000C 		mov	ip, #0
 2870 003e 09E0     		b	.L197
 2871              	.LVL200:
 2872              	.L192:
1731:Src/util.c    ****   }
 2873              		.loc 1 1731 5 is_stmt 1 view .LVU764
1731:Src/util.c    ****   }
 2874              		.loc 1 1731 17 is_stmt 0 view .LVU765
 2875 0040 B0F5167F 		cmp	r0, #600
 2876 0044 D4BF     		ite	le
 2877 0046 0020     		movle	r0, #0
 2878              	.LVL201:
ARM GAS  /tmp/ccQoOasm.s 			page 88


1731:Src/util.c    ****   }
 2879              		.loc 1 1731 17 view .LVU766
 2880 0048 0120     		movgt	r0, #1
 2881              	.LVL202:
1731:Src/util.c    ****   }
 2882              		.loc 1 1731 17 view .LVU767
 2883 004a E0E7     		b	.L193
 2884              	.LVL203:
 2885              	.L199:
1739:Src/util.c    ****   } else {
 2886              		.loc 1 1739 12 view .LVU768
 2887 004c 0C46     		mov	r4, r1
 2888 004e E7E7     		b	.L195
 2889              	.LVL204:
 2890              	.L201:
 2891              		.loc 1 1756 19 view .LVU769
 2892 0050 4FF0000C 		mov	ip, #0
 2893              	.L197:
 2894              	.LVL205:
1757:Src/util.c    ****   } else {
1758:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1759:Src/util.c    ****   }
1760:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 2895              		.loc 1 1760 3 is_stmt 1 view .LVU770
 2896              		.loc 1 1760 14 is_stmt 0 view .LVU771
 2897 0054 6344     		add	r3, r3, ip
 2898              	.LVL206:
 2899              		.loc 1 1760 14 view .LVU772
 2900 0056 DBB2     		uxtb	r3, r3
 2901              	.LVL207:
1761:Src/util.c    **** 
1762:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1763:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 2902              		.loc 1 1763 3 is_stmt 1 view .LVU773
 2903              		.loc 1 1763 6 is_stmt 0 view .LVU774
 2904 0058 032B     		cmp	r3, #3
 2905 005a 07D9     		bls	.L198
 2906              		.loc 1 1763 39 discriminator 1 view .LVU775
 2907 005c B1F5FA6F 		cmp	r1, #2000
 2908 0060 04D8     		bhi	.L198
1764:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 2909              		.loc 1 1764 5 is_stmt 1 view .LVU776
 2910              		.loc 1 1764 26 is_stmt 0 view .LVU777
 2911 0062 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 2912              	.LVL208:
 2913              		.loc 1 1764 24 view .LVU778
 2914 0064 B1FA81F1 		clz	r1, r1
 2915 0068 4909     		lsrs	r1, r1, #5
 2916              		.loc 1 1764 22 view .LVU779
 2917 006a 9171     		strb	r1, [r2, #6]
 2918              	.L198:
1765:Src/util.c    ****   }
1766:Src/util.c    **** 
1767:Src/util.c    ****   // Update states
1768:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 2919              		.loc 1 1768 3 is_stmt 1 view .LVU780
 2920              		.loc 1 1768 21 is_stmt 0 view .LVU781
ARM GAS  /tmp/ccQoOasm.s 			page 89


 2921 006c 1371     		strb	r3, [r2, #4]
1769:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 2922              		.loc 1 1769 3 is_stmt 1 view .LVU782
 2923              		.loc 1 1769 20 is_stmt 0 view .LVU783
 2924 006e 5071     		strb	r0, [r2, #5]
 2925              	.LVL209:
1770:Src/util.c    ****   x->t_timePrev 	  = t_time;
 2926              		.loc 1 1770 3 is_stmt 1 view .LVU784
 2927              		.loc 1 1770 20 is_stmt 0 view .LVU785
 2928 0070 1460     		str	r4, [r2]
1771:Src/util.c    **** }
 2929              		.loc 1 1771 1 view .LVU786
 2930 0072 30BC     		pop	{r4, r5}
 2931              	.LCFI25:
 2932              		.cfi_restore 5
 2933              		.cfi_restore 4
 2934              		.cfi_def_cfa_offset 0
 2935              	.LVL210:
 2936              		.loc 1 1771 1 view .LVU787
 2937 0074 7047     		bx	lr
 2938              		.cfi_endproc
 2939              	.LFE97:
 2941              		.section	.bss.old_pos.0,"aw",%nobits
 2942              		.align	2
 2945              	old_pos.0:
 2946 0000 00000000 		.space	4
 2947              		.section	.bss.commandL_raw,"aw",%nobits
 2948              		.align	2
 2951              	commandL_raw:
 2952 0000 00000000 		.space	8
 2952      00000000 
 2953              		.section	.bss.commandL,"aw",%nobits
 2954              		.align	2
 2957              	commandL:
 2958 0000 00000000 		.space	8
 2958      00000000 
 2959              		.section	.bss.timeoutFlgSerial_L,"aw",%nobits
 2962              	timeoutFlgSerial_L:
 2963 0000 00       		.space	1
 2964              		.section	.data.timeoutCntSerial_L,"aw"
 2965              		.align	1
 2968              	timeoutCntSerial_L:
 2969 0000 A000     		.short	160
 2970              		.section	.bss.rx_buffer_L,"aw",%nobits
 2971              		.align	2
 2974              	rx_buffer_L:
 2975 0000 00000000 		.space	64
 2975      00000000 
 2975      00000000 
 2975      00000000 
 2975      00000000 
 2976              		.section	.bss.cur_spd_valid,"aw",%nobits
 2979              	cur_spd_valid:
 2980 0000 00       		.space	1
 2981              		.section	.bss.INPUT_MIN,"aw",%nobits
 2982              		.align	1
 2985              	INPUT_MIN:
ARM GAS  /tmp/ccQoOasm.s 			page 90


 2986 0000 0000     		.space	2
 2987              		.section	.bss.INPUT_MAX,"aw",%nobits
 2988              		.align	1
 2991              	INPUT_MAX:
 2992 0000 0000     		.space	2
 2993              		.global	VirtAddVarTab
 2994              		.section	.data.VirtAddVarTab,"aw"
 2995              		.align	2
 2998              	VirtAddVarTab:
 2999 0000 E803     		.short	1000
 3000 0002 E903     		.short	1001
 3001 0004 EA03     		.short	1002
 3002 0006 EB03     		.short	1003
 3003 0008 EC03     		.short	1004
 3004 000a ED03     		.short	1005
 3005 000c EE03     		.short	1006
 3006 000e EF03     		.short	1007
 3007 0010 F003     		.short	1008
 3008 0012 F103     		.short	1009
 3009 0014 F203     		.short	1010
 3010 0016 F303     		.short	1011
 3011 0018 F403     		.short	1012
 3012 001a F503     		.short	1013
 3013 001c F603     		.short	1014
 3014 001e F703     		.short	1015
 3015 0020 F803     		.short	1016
 3016 0022 F903     		.short	1017
 3017 0024 FA03     		.short	1018
 3018              		.global	ctrlModReq
 3019              		.section	.data.ctrlModReq,"aw"
 3022              	ctrlModReq:
 3023 0000 02       		.byte	2
 3024              		.global	ctrlModReqRaw
 3025              		.section	.data.ctrlModReqRaw,"aw"
 3028              	ctrlModReqRaw:
 3029 0000 02       		.byte	2
 3030              		.global	timeoutFlgSerial
 3031              		.section	.bss.timeoutFlgSerial,"aw",%nobits
 3034              	timeoutFlgSerial:
 3035 0000 00       		.space	1
 3036              		.global	timeoutFlgADC
 3037              		.section	.bss.timeoutFlgADC,"aw",%nobits
 3040              	timeoutFlgADC:
 3041 0000 00       		.space	1
 3042              		.global	speedAvgAbs
 3043              		.section	.bss.speedAvgAbs,"aw",%nobits
 3044              		.align	1
 3047              	speedAvgAbs:
 3048 0000 0000     		.space	2
 3049              		.global	speedAvg
 3050              		.section	.bss.speedAvg,"aw",%nobits
 3051              		.align	1
 3054              	speedAvg:
 3055 0000 0000     		.space	2
 3056              		.global	input2
 3057              		.section	.data.input2,"aw"
 3058              		.align	2
ARM GAS  /tmp/ccQoOasm.s 			page 91


 3061              	input2:
 3062 0000 0000     		.short	0
 3063 0002 0000     		.short	0
 3064 0004 00       		.byte	0
 3065 0005 03       		.byte	3
 3066 0006 18FC     		.short	-1000
 3067 0008 0000     		.short	0
 3068 000a E803     		.short	1000
 3069 000c 0000     		.short	0
 3070              		.global	input1
 3071              		.section	.data.input1,"aw"
 3072              		.align	2
 3075              	input1:
 3076 0000 0000     		.short	0
 3077 0002 0000     		.short	0
 3078 0004 00       		.byte	0
 3079 0005 03       		.byte	3
 3080 0006 18FC     		.short	-1000
 3081 0008 0000     		.short	0
 3082 000a E803     		.short	1000
 3083 000c 0000     		.short	0
 3084              		.global	inIdx_prev
 3085              		.section	.bss.inIdx_prev,"aw",%nobits
 3088              	inIdx_prev:
 3089 0000 00       		.space	1
 3090              		.global	inIdx
 3091              		.section	.bss.inIdx,"aw",%nobits
 3094              	inIdx:
 3095 0000 00       		.space	1
 3096              		.global	rtY_Right
 3097              		.section	.bss.rtY_Right,"aw",%nobits
 3098              		.align	2
 3101              	rtY_Right:
 3102 0000 00000000 		.space	16
 3102      00000000 
 3102      00000000 
 3102      00000000 
 3103              		.global	rtU_Right
 3104              		.section	.bss.rtU_Right,"aw",%nobits
 3105              		.align	2
 3108              	rtU_Right:
 3109 0000 00000000 		.space	16
 3109      00000000 
 3109      00000000 
 3109      00000000 
 3110              		.global	rtDW_Right
 3111              		.section	.bss.rtDW_Right,"aw",%nobits
 3112              		.align	2
 3115              	rtDW_Right:
 3116 0000 00000000 		.space	172
 3116      00000000 
 3116      00000000 
 3116      00000000 
 3116      00000000 
 3117              		.global	rtP_Right
 3118              		.section	.bss.rtP_Right,"aw",%nobits
 3119              		.align	2
ARM GAS  /tmp/ccQoOasm.s 			page 92


 3122              	rtP_Right:
 3123 0000 00000000 		.space	256
 3123      00000000 
 3123      00000000 
 3123      00000000 
 3123      00000000 
 3124              		.global	rtY_Left
 3125              		.section	.bss.rtY_Left,"aw",%nobits
 3126              		.align	2
 3129              	rtY_Left:
 3130 0000 00000000 		.space	16
 3130      00000000 
 3130      00000000 
 3130      00000000 
 3131              		.global	rtU_Left
 3132              		.section	.bss.rtU_Left,"aw",%nobits
 3133              		.align	2
 3136              	rtU_Left:
 3137 0000 00000000 		.space	16
 3137      00000000 
 3137      00000000 
 3137      00000000 
 3138              		.global	rtDW_Left
 3139              		.section	.bss.rtDW_Left,"aw",%nobits
 3140              		.align	2
 3143              	rtDW_Left:
 3144 0000 00000000 		.space	172
 3144      00000000 
 3144      00000000 
 3144      00000000 
 3144      00000000 
 3145              		.global	rtM_Right
 3146              		.section	.rodata.rtM_Right,"a"
 3147              		.align	2
 3150              	rtM_Right:
 3151 0000 00000000 		.word	rtM_Right_
 3152              		.global	rtM_Left
 3153              		.section	.rodata.rtM_Left,"a"
 3154              		.align	2
 3157              	rtM_Left:
 3158 0000 00000000 		.word	rtM_Left_
 3159              		.global	rtM_Right_
 3160              		.section	.bss.rtM_Right_,"aw",%nobits
 3161              		.align	2
 3164              	rtM_Right_:
 3165 0000 00000000 		.space	16
 3165      00000000 
 3165      00000000 
 3165      00000000 
 3166              		.global	rtM_Left_
 3167              		.section	.bss.rtM_Left_,"aw",%nobits
 3168              		.align	2
 3171              	rtM_Left_:
 3172 0000 00000000 		.space	16
 3172      00000000 
 3172      00000000 
 3172      00000000 
ARM GAS  /tmp/ccQoOasm.s 			page 93


 3173              		.text
 3174              	.Letext0:
 3175              		.file 2 "/usr/lib/gcc/arm-none-eabi/13.2.1/include/stddef.h"
 3176              		.file 3 "/usr/lib/gcc/arm-none-eabi/13.2.1/include/stdint.h"
 3177              		.file 4 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 3178              		.file 5 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 3179              		.file 6 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 3180              		.file 7 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 3181              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 3182              		.file 9 "Inc/util.h"
 3183              		.file 10 "Inc/rtwtypes.h"
 3184              		.file 11 "Inc/BLDC_controller.h"
 3185              		.file 12 "Inc/eeprom.h"
 3186              		.file 13 "/usr/include/newlib/string.h"
 3187              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3188              		.file 15 "/usr/include/newlib/stdio.h"
 3189              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_flash.h"
 3190              		.file 17 "Inc/setup.h"
 3191              		.file 18 "<built-in>"
ARM GAS  /tmp/ccQoOasm.s 			page 94


DEFINED SYMBOLS
                            *ABS*:00000000 util.c
     /tmp/ccQoOasm.s:19     .text.BLDC_Init:00000000 $t
     /tmp/ccQoOasm.s:25     .text.BLDC_Init:00000000 BLDC_Init
     /tmp/ccQoOasm.s:135    .text.BLDC_Init:00000088 $d
     /tmp/ccQoOasm.s:3122   .bss.rtP_Right:00000000 rtP_Right
     /tmp/ccQoOasm.s:3171   .bss.rtM_Left_:00000000 rtM_Left_
     /tmp/ccQoOasm.s:3143   .bss.rtDW_Left:00000000 rtDW_Left
     /tmp/ccQoOasm.s:3136   .bss.rtU_Left:00000000 rtU_Left
     /tmp/ccQoOasm.s:3129   .bss.rtY_Left:00000000 rtY_Left
     /tmp/ccQoOasm.s:3164   .bss.rtM_Right_:00000000 rtM_Right_
     /tmp/ccQoOasm.s:3115   .bss.rtDW_Right:00000000 rtDW_Right
     /tmp/ccQoOasm.s:3108   .bss.rtU_Right:00000000 rtU_Right
     /tmp/ccQoOasm.s:3101   .bss.rtY_Right:00000000 rtY_Right
     /tmp/ccQoOasm.s:149    .text.Input_Lim_Init:00000000 $t
     /tmp/ccQoOasm.s:155    .text.Input_Lim_Init:00000000 Input_Lim_Init
     /tmp/ccQoOasm.s:201    .text.Input_Lim_Init:00000034 $d
     /tmp/ccQoOasm.s:2991   .bss.INPUT_MAX:00000000 INPUT_MAX
     /tmp/ccQoOasm.s:2985   .bss.INPUT_MIN:00000000 INPUT_MIN
     /tmp/ccQoOasm.s:209    .text.UART_DisableRxErrors:00000000 $t
     /tmp/ccQoOasm.s:215    .text.UART_DisableRxErrors:00000000 UART_DisableRxErrors
     /tmp/ccQoOasm.s:239    .text.poweronMelody:00000000 $t
     /tmp/ccQoOasm.s:245    .text.poweronMelody:00000000 poweronMelody
     /tmp/ccQoOasm.s:299    .text.poweronMelody:00000024 $d
     /tmp/ccQoOasm.s:305    .text.beepCount:00000000 $t
     /tmp/ccQoOasm.s:311    .text.beepCount:00000000 beepCount
     /tmp/ccQoOasm.s:336    .text.beepCount:00000010 $d
     /tmp/ccQoOasm.s:343    .text.beepLong:00000000 $t
     /tmp/ccQoOasm.s:349    .text.beepLong:00000000 beepLong
     /tmp/ccQoOasm.s:387    .text.beepLong:00000018 $d
     /tmp/ccQoOasm.s:393    .text.beepShort:00000000 $t
     /tmp/ccQoOasm.s:399    .text.beepShort:00000000 beepShort
     /tmp/ccQoOasm.s:437    .text.beepShort:00000018 $d
     /tmp/ccQoOasm.s:443    .text.beepShortMany:00000000 $t
     /tmp/ccQoOasm.s:449    .text.beepShortMany:00000000 beepShortMany
     /tmp/ccQoOasm.s:530    .text.calcAvgSpeed:00000000 $t
     /tmp/ccQoOasm.s:536    .text.calcAvgSpeed:00000000 calcAvgSpeed
     /tmp/ccQoOasm.s:582    .text.calcAvgSpeed:00000030 $d
     /tmp/ccQoOasm.s:3054   .bss.speedAvg:00000000 speedAvg
     /tmp/ccQoOasm.s:3047   .bss.speedAvgAbs:00000000 speedAvgAbs
     /tmp/ccQoOasm.s:590    .text.adcCalibLim:00000000 $t
     /tmp/ccQoOasm.s:596    .text.adcCalibLim:00000000 adcCalibLim
     /tmp/ccQoOasm.s:609    .text.standstillHold:00000000 $t
     /tmp/ccQoOasm.s:615    .text.standstillHold:00000000 standstillHold
     /tmp/ccQoOasm.s:628    .text.electricBrake:00000000 $t
     /tmp/ccQoOasm.s:634    .text.electricBrake:00000000 electricBrake
     /tmp/ccQoOasm.s:648    .text.cruiseControl:00000000 $t
     /tmp/ccQoOasm.s:654    .text.cruiseControl:00000000 cruiseControl
     /tmp/ccQoOasm.s:668    .text.checkInputType:00000000 $t
     /tmp/ccQoOasm.s:674    .text.checkInputType:00000000 checkInputType
     /tmp/ccQoOasm.s:766    .text.checkInputType:00000058 $d
     /tmp/ccQoOasm.s:771    .rodata.Input_Init.str1.4:00000000 $d
     /tmp/ccQoOasm.s:776    .text.Input_Init:00000000 $t
     /tmp/ccQoOasm.s:782    .text.Input_Init:00000000 Input_Init
     /tmp/ccQoOasm.s:1146   .text.Input_Init:0000021c $d
     /tmp/ccQoOasm.s:2974   .bss.rx_buffer_L:00000000 rx_buffer_L
     /tmp/ccQoOasm.s:2998   .data.VirtAddVarTab:00000000 VirtAddVarTab
ARM GAS  /tmp/ccQoOasm.s 			page 95


     /tmp/ccQoOasm.s:3075   .data.input1:00000000 input1
     /tmp/ccQoOasm.s:3061   .data.input2:00000000 input2
     /tmp/ccQoOasm.s:1159   .text.calcInputCmd:00000000 $t
     /tmp/ccQoOasm.s:1165   .text.calcInputCmd:00000000 calcInputCmd
     /tmp/ccQoOasm.s:1306   .text.readInputRaw:00000000 $t
     /tmp/ccQoOasm.s:1312   .text.readInputRaw:00000000 readInputRaw
     /tmp/ccQoOasm.s:1348   .text.readInputRaw:00000028 $d
     /tmp/ccQoOasm.s:3094   .bss.inIdx:00000000 inIdx
     /tmp/ccQoOasm.s:2957   .bss.commandL:00000000 commandL
     /tmp/ccQoOasm.s:1356   .text.handleTimeout:00000000 $t
     /tmp/ccQoOasm.s:1362   .text.handleTimeout:00000000 handleTimeout
     /tmp/ccQoOasm.s:1480   .text.handleTimeout:0000007c $d
     /tmp/ccQoOasm.s:2968   .data.timeoutCntSerial_L:00000000 timeoutCntSerial_L
     /tmp/ccQoOasm.s:2962   .bss.timeoutFlgSerial_L:00000000 timeoutFlgSerial_L
     /tmp/ccQoOasm.s:3034   .bss.timeoutFlgSerial:00000000 timeoutFlgSerial
     /tmp/ccQoOasm.s:3040   .bss.timeoutFlgADC:00000000 timeoutFlgADC
     /tmp/ccQoOasm.s:3022   .data.ctrlModReq:00000000 ctrlModReq
     /tmp/ccQoOasm.s:3088   .bss.inIdx_prev:00000000 inIdx_prev
     /tmp/ccQoOasm.s:3028   .data.ctrlModReqRaw:00000000 ctrlModReqRaw
     /tmp/ccQoOasm.s:1495   .text.readCommand:00000000 $t
     /tmp/ccQoOasm.s:1501   .text.readCommand:00000000 readCommand
     /tmp/ccQoOasm.s:1552   .text.readCommand:00000044 $d
     /tmp/ccQoOasm.s:1561   .text.usart3_rx_check:00000000 $t
     /tmp/ccQoOasm.s:1567   .text.usart3_rx_check:00000000 usart3_rx_check
     /tmp/ccQoOasm.s:1580   .text.usart_process_command:00000000 $t
     /tmp/ccQoOasm.s:1586   .text.usart_process_command:00000000 usart_process_command
     /tmp/ccQoOasm.s:1673   .text.usart_process_command:00000058 $d
     /tmp/ccQoOasm.s:1681   .text.usart2_rx_check:00000000 $t
     /tmp/ccQoOasm.s:1687   .text.usart2_rx_check:00000000 usart2_rx_check
     /tmp/ccQoOasm.s:1815   .text.usart2_rx_check:00000080 $d
     /tmp/ccQoOasm.s:2945   .bss.old_pos.0:00000000 old_pos.0
     /tmp/ccQoOasm.s:2951   .bss.commandL_raw:00000000 commandL_raw
     /tmp/ccQoOasm.s:1824   .text.sideboardLeds:00000000 $t
     /tmp/ccQoOasm.s:1830   .text.sideboardLeds:00000000 sideboardLeds
     /tmp/ccQoOasm.s:1844   .text.sideboardSensors:00000000 $t
     /tmp/ccQoOasm.s:1850   .text.sideboardSensors:00000000 sideboardSensors
     /tmp/ccQoOasm.s:1864   .text.saveConfig:00000000 $t
     /tmp/ccQoOasm.s:1870   .text.saveConfig:00000000 saveConfig
     /tmp/ccQoOasm.s:2035   .text.saveConfig:000000e0 $d
     /tmp/ccQoOasm.s:2979   .bss.cur_spd_valid:00000000 cur_spd_valid
     /tmp/ccQoOasm.s:2045   .text.poweroff:00000000 $t
     /tmp/ccQoOasm.s:2051   .text.poweroff:00000000 poweroff
     /tmp/ccQoOasm.s:2116   .text.poweroff:00000034 $d
     /tmp/ccQoOasm.s:2125   .text.filtLowPass32:00000000 $t
     /tmp/ccQoOasm.s:2131   .text.filtLowPass32:00000000 filtLowPass32
     /tmp/ccQoOasm.s:2200   .text.updateCurSpdLim:00000000 $t
     /tmp/ccQoOasm.s:2206   .text.updateCurSpdLim:00000000 updateCurSpdLim
     /tmp/ccQoOasm.s:2440   .text.updateCurSpdLim:0000014c $d
     /tmp/ccQoOasm.s:2452   .text.poweroffPressCheck:00000000 $t
     /tmp/ccQoOasm.s:2458   .text.poweroffPressCheck:00000000 poweroffPressCheck
     /tmp/ccQoOasm.s:2583   .text.poweroffPressCheck:00000088 $d
     /tmp/ccQoOasm.s:2590   .text.rateLimiter16:00000000 $t
     /tmp/ccQoOasm.s:2596   .text.rateLimiter16:00000000 rateLimiter16
     /tmp/ccQoOasm.s:2648   .text.mixerFcn:00000000 $t
     /tmp/ccQoOasm.s:2654   .text.mixerFcn:00000000 mixerFcn
     /tmp/ccQoOasm.s:2774   .text.mixerFcn:00000070 $d
     /tmp/ccQoOasm.s:2781   .text.multipleTapDet:00000000 $t
ARM GAS  /tmp/ccQoOasm.s 			page 96


     /tmp/ccQoOasm.s:2787   .text.multipleTapDet:00000000 multipleTapDet
     /tmp/ccQoOasm.s:2942   .bss.old_pos.0:00000000 $d
     /tmp/ccQoOasm.s:2948   .bss.commandL_raw:00000000 $d
     /tmp/ccQoOasm.s:2954   .bss.commandL:00000000 $d
     /tmp/ccQoOasm.s:2963   .bss.timeoutFlgSerial_L:00000000 $d
     /tmp/ccQoOasm.s:2965   .data.timeoutCntSerial_L:00000000 $d
     /tmp/ccQoOasm.s:2971   .bss.rx_buffer_L:00000000 $d
     /tmp/ccQoOasm.s:2980   .bss.cur_spd_valid:00000000 $d
     /tmp/ccQoOasm.s:2982   .bss.INPUT_MIN:00000000 $d
     /tmp/ccQoOasm.s:2988   .bss.INPUT_MAX:00000000 $d
     /tmp/ccQoOasm.s:2995   .data.VirtAddVarTab:00000000 $d
     /tmp/ccQoOasm.s:3035   .bss.timeoutFlgSerial:00000000 $d
     /tmp/ccQoOasm.s:3041   .bss.timeoutFlgADC:00000000 $d
     /tmp/ccQoOasm.s:3044   .bss.speedAvgAbs:00000000 $d
     /tmp/ccQoOasm.s:3051   .bss.speedAvg:00000000 $d
     /tmp/ccQoOasm.s:3058   .data.input2:00000000 $d
     /tmp/ccQoOasm.s:3072   .data.input1:00000000 $d
     /tmp/ccQoOasm.s:3089   .bss.inIdx_prev:00000000 $d
     /tmp/ccQoOasm.s:3095   .bss.inIdx:00000000 $d
     /tmp/ccQoOasm.s:3098   .bss.rtY_Right:00000000 $d
     /tmp/ccQoOasm.s:3105   .bss.rtU_Right:00000000 $d
     /tmp/ccQoOasm.s:3112   .bss.rtDW_Right:00000000 $d
     /tmp/ccQoOasm.s:3119   .bss.rtP_Right:00000000 $d
     /tmp/ccQoOasm.s:3126   .bss.rtY_Left:00000000 $d
     /tmp/ccQoOasm.s:3133   .bss.rtU_Left:00000000 $d
     /tmp/ccQoOasm.s:3140   .bss.rtDW_Left:00000000 $d
     /tmp/ccQoOasm.s:3150   .rodata.rtM_Right:00000000 rtM_Right
     /tmp/ccQoOasm.s:3147   .rodata.rtM_Right:00000000 $d
     /tmp/ccQoOasm.s:3157   .rodata.rtM_Left:00000000 rtM_Left
     /tmp/ccQoOasm.s:3154   .rodata.rtM_Left:00000000 $d
     /tmp/ccQoOasm.s:3161   .bss.rtM_Right_:00000000 $d
     /tmp/ccQoOasm.s:3168   .bss.rtM_Left_:00000000 $d

UNDEFINED SYMBOLS
memcpy
BLDC_controller_initialize
rtP_Left
HAL_Delay
buzzerCount
buzzerFreq
buzzerPattern
UART2_Init
HAL_UART_Receive_DMA
HAL_FLASH_Unlock
EE_Init
EE_ReadVariable
printf
HAL_FLASH_Lock
huart2
timeoutFlgGen
inactivity_timeout_counter
EE_WriteVariable
HAL_GPIO_WritePin
enable
HAL_GPIO_ReadPin
